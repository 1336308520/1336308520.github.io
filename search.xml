<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AJAX]]></title>
    <url>%2F2019%2F08%2F24%2F27%2F</url>
    <content type="text"><![CDATA[AJAX AJAX:”Asynchronous JavaScript and XML”中文意思：异步JavaScript和XML。指一种创建交互式网页应用的网页开发技术。AJAX并非缩写词,而是由Jesse James Gaiiett创造的名词。 不是指一种单一的技术，而是有机地利用了一系列相关的技术：web标准( Standards-Based Presentation )XHTML+CSS的表示,使用 DOM( Document Object Model )进行动态显示及交互,使用 XML 和 XSLT 进行数据交换及相关操作,使用 XMLHttpRequest 进行异步数据查询、检索. 简单理解为：JavaScript + XMLHttpRequest + CSS +服务器端 的集合. AJAX优点传统的web应用允许用户向web服务器发送一个请求。服务器接收并处理，然后返回一个新的网页。 这个做法浪费了许多带宽，因为在前后两个页面中的大部分HTML代码往往是相同的。 AJAX应用可以仅向服务器发送并取回必需的数据，并在客户端采用JavaScript处理来自服务器的响应 因为在服务器和浏览器之间交换的数据大量减少（大约只有原来的5%），结果我们就能看到响应更快的应用。同时很多的处理工作可以在发出请求的客户端机器上完成，所以Web服务器的处理时间也减少了。 Ajax在本质上是一个浏览器端的技术 Ajax技术之主要目的在于局部交换客户端及服务器间之数据 能够不用重新载入整个版面来更新资料，也就是所谓的Refresh without Reload(轻刷新) 与服务器之间的沟通，完全是透过Javascript 来实行 本身传送的资料量很小，反应更快，让网络程序更像一个桌面应用程序 AJAX 就是运用Javascript 在后台悄悄帮你去跟服务器要资料，最后再由Javascript 或DOM 来帮你呈现结果，因为所有动作都是由Javascript 代劳，所以省去了网页重载的麻烦，使用者也感受不到等待的痛苦 XMLHttpRequest对象 XMLHttpRequest对象是Ajax应用程序的中心。在IE浏览器和非IE浏览器中创建的方法不同。XMLHttpRequest对象允许用javascript通过HTTP连接到服务器，而不是通过HTTP请求响应模型与服务器通信。简而言之：它可以异步从服务器端获取txt或者xml数据 创建XMLHttpRequest对象一、先来创建XMLHttpRequest对象 在IE、Firefox、safari和Opera中创建该对象的JavaScript代码为： var xhr = new XMLHttpRequest();在IE5/6中代码为： var xmlRequest = new ActiveXObject(“Microsoft.XMLHTTP”); 注意，JavaScript区分大小写。 二、为XMLHttpRequest对象设置请求参数open(method, url, async, username, password) 1.设置参数： xhr.open(“GET”, “index.jsp”, true);2.POST方式： xhr.open(“POST”, “index.jsp”, true); 三、发送请求：(分别对应GET和POST)xhr.send(null);//GET方式不能传值，用nullxhr.send(“a=1&amp;b=123”);//POST方式可传值 回调函数 请求发出去之后会有响应，如何处理呢？XMLHttpRequest对象有个onreadystatechange事件，当状态发生变化时就会触发 1234567891.编写回调函数function hehe() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; var msg = xhr.responseText; //服务器返回的字符串 &#125; else alert("服务器错误!" + xhr.status); &#125;&#125;2.在xhr.send之前添加设置回调函数代码：xhr.onreadystatechange = hehe; status属性服务器发送的每一个响应也都带有首部信息。三位数的状态码是服务器发送的响应中最重要的首部信息，并且属于超文本传输协议中的一部分。常用状态码及其含义：404 没找到页面(not found)403 禁止访问(forbidden)500 内部服务器出错(internal service error)200 一切正常(ok)304 没有被修改(not modified)在 XMLHttpRequest 对象中，服务器发送的状态码都保存在 status 属性里。通过把这个值和 200 或 304 比较，可以确保服务器是否已发送了一个成功的响应 readyState属性 readyState属性指出了XMLHttpRequest对象在发送/接收数据过程中所处的几个状态。XMLHttpRequest对象会经历5种不同的状态。0：未初始化。对象已经创建，但还未初始化，即还没调用open方法；1：已打开。对象已经创建并初始化，但还未调用send方法；2：已发送。已经调用send 方法，但该对象正在等待状态码和头的返回；3：正在接收。已经接收了部分数据，但还不能使用该对象的属性和方法，因为状态和响应头不完整；4：已加载。所有数据接收完毕 responseText属性XMLHttpRequest 的 responseText 属性包含了从服务器得到的数据。它是一个HTML,XML或普通文本，这取决于服务器发送的内容。当 readyState 属性值变成 4 时, responseText 属性才可用，表明 Ajax 请求已经结束。 index.jsp1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;% String path = request.getContextPath(); %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;服务器时间：&lt;span id ="dt"&gt;&lt;/span&gt;&lt;br/&gt;&lt;input type="button" value="刷新时间" onclick="shua();"/&gt;&lt;script type="text/javascript"&gt;function shua()&#123; //异步对象,可以发送异步请求，可以接收服务器响应。 var obj = new XMLHttpRequest(); /* obj.readyState:准备状态：1，2，3，4 obj.status:服务器响应状态码：(404/403/500/200/304) obj.responseText:服务器给我们的响应文本 obj.onreadystatechange事件:radyState发生改变时触发 */ obj.onreadystatechange = function()&#123; var isLast = (obj.readyState==4);//已经加载完毕 var isSuccess = (obj.status==200||obj.status==304);//服务器响应成功(本次请求成功) if(isLast &amp;&amp; isSuccess)&#123; var data = obj.responseText;//获取服务器响应文本 var el = document.getElementById("dt"); el.innerHTML = data; &#125; &#125; //要去哪里访问 obj.open("get","&lt;%=path%&gt;/date.jsp"); //去，参数会传递到服务器 obj.send(null); setTimeout("shua()",1000);&#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; data.jsp1234&lt;%@page import="java.util.Date"%&gt;&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;% out.print(new Date()); %&gt; # hasName.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package user;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class hasName */@WebServlet("/hasName")public class hasName extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public hasName() &#123; // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub request.setCharacterEncoding("UTF-8"); String name = request.getParameter("un"); System.out.println("准备检测用户名："+name); if("admin".equals(name))&#123; //存在 response.getWriter().print("1"); return; &#125;else&#123; response.getWriter().print("0"); return; &#125; &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doGet(request, response); &#125;&#125; register.jsp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;% String path = request.getContextPath();response.setCharacterEncoding("UTF-8"); %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;用户名：&lt;input type="text" id="yhm"/&gt;&lt;input type="button" value="检测用户名是否存在" onclick="jiance();"/&gt;&lt;script type="text/javascript"&gt;function jiance()&#123; //异步对象,可以发送异步请求，可以接收服务器响应。 var obj = new XMLHttpRequest(); /* obj.readyState:准备状态：1，2，3，4 obj.status:服务器响应状态码：(404/403/500/200/304) obj.responseText:服务器给我们的响应文本 obj.onreadystatechange事件:radyState发生改变时触发 */ obj.onreadystatechange = function()&#123; var isLast = (obj.readyState==4);//已经加载完毕 var isSuccess = (obj.status==200||obj.status==304);//服务器响应成功(本次请求成功) if(isLast &amp;&amp; isSuccess)&#123; var data = obj.responseText;//获取服务器响应文本 alert(data); &#125; &#125; var val = document.getElementById("yhm").value; //要去哪里访问 obj.open("post","&lt;%=path%&gt;/hasName"); obj.setRequestHeader("Content-type","application/x-www-form-urlencoded"); //去，参数会传递到服务器 obj.send("un="+val); //setTimeout("shua()",1000);&#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 自定义AJAX工具类MyAjax.jsp1234567891011121314151617&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;% String path = request.getContextPath(); %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script type="text/javascript" src="&lt;%=path%&gt;/js/ajax.js"&gt;&lt;/script&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript"&gt;ajaxGet("&lt;%=path%&gt;/hasName","un=admi",function(er)&#123;alert(er);&#125;,function(em)&#123;alert(em);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 新建js文件夹，里面新建ajax.js1234567891011121314151617181920System.out.println("hello");function ajaxGet(url,param,callSuc,callErr)&#123;var obj = new XMLHttpRequest();obj.onreadystatechange = function()&#123; var isLast = (obj.readyState==4); var isSuccess = (obj.status==200||obj.status==304); if(isLast)&#123; if(isSuccess)&#123; var result = obj.responseText; if(callSuc) callSuc(result); &#125;else&#123; if(callErr) callErr(obj.status); &#125; &#125;&#125;obj.open("get",url+"?"+param);obj.send(null);&#125;]]></content>
      <categories>
        <category>JAVA个人笔记</category>
      </categories>
      <tags>
        <tag>JAVA个人笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周末复习]]></title>
    <url>%2F2019%2F08%2F11%2F26%2F</url>
    <content type="text"><![CDATA[JSP复习index.jsp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;%@page import="demo.user.User"%&gt;&lt;%@page import="java.util.List"%&gt;&lt;%@page import="demo.factory.DaoFactory"%&gt;&lt;%@page import="dao.Dao"%&gt;&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;style type="text/css"&gt;#customers &#123; font-family:"Trebuchet MS", Arial, Helvetica, sans-serif; width:100%; border-collapse:collapse; &#125;#customers td, #customers th &#123; font-size:1em; border:1px solid #98bf21; padding:3px 7px 2px 7px; &#125;#customers th &#123; font-size:1.1em; text-align:left; padding-top:5px; padding-bottom:4px; background-color:#A7C942; color:#ffffff; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;table id="customers"&gt;&lt;tr&gt;&lt;th&gt;ID&lt;/th&gt;&lt;th&gt;NAME&lt;/th&gt;&lt;th&gt;PASS&lt;/th&gt;&lt;th&gt;操作&lt;/th&gt;&lt;/tr&gt;&lt;% String path = request.getContextPath();Dao dao = DaoFactory.getDao();List&lt;User&gt;list = dao.findAll();for(int i = 0;i&lt;list.size();i++)&#123; User us = list.get(i);%&gt;&lt;tr&gt;&lt;td&gt;&lt;%=us.getId()%&gt;&lt;/td&gt;&lt;td&gt;&lt;%=us.getName()%&gt;&lt;/td&gt;&lt;td&gt;&lt;%=us.getPass()%&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="&lt;%=path%&gt;/readychange.jsp?id=&lt;%=us.getId()%&gt;"&gt;&lt;button&gt;修改&lt;/button&gt;&lt;/a&gt;&lt;button onclick ="shanchu(&lt;%=us.getId()%&gt;);"&gt;删除&lt;/button&gt;&lt;/td&gt;&lt;/tr&gt;&lt;% &#125; %&gt;&lt;/table&gt;&lt;script type="text/javascript"&gt;function shanchu(uid)&#123;if(window.confirm("确定要删除吗？"))&#123; window.location.href="&lt;%=path%&gt;/del.jsp?xx="+uid;&#125;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; change.jsp12345678910111213141516171819202122232425262728&lt;%@page import="demo.user.User"%&gt;&lt;%@page import="dao.Dao"%&gt;&lt;%@page import="demo.factory.DaoFactory"%&gt;&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%String path = request.getContextPath();String st = request.getParameter("id");int id = Integer.parseInt(st);String name = request.getParameter("name");String pass = request.getParameter("password");Dao dao = DaoFactory.getDao();User us= new User();us.setId(id);us.setName(name);us.setPass(pass);dao.update(us);response.sendRedirect(path+"/index.jsp");%&gt;&lt;/body&gt;&lt;/html&gt; readychange.jsp123456789101112131415161718192021222324252627&lt;%@page import="demo.factory.DaoFactory"%&gt;&lt;%@page import="dao.Dao"%&gt;&lt;%@page import="demo.user.User"%&gt;&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%String path = request.getContextPath();String st = request.getParameter("id");int id = Integer.parseInt(st);Dao dao = DaoFactory.getDao();User us= dao.findById(id);%&gt;&lt;form action ="&lt;%=path%&gt;/change.jsp" method = "post"&gt; &lt;input type="text" name="id" value="&lt;%=us.getId()%&gt;" readonly="readonly"/&gt;&lt;input type = "text" name ="name" value="&lt;%=us.getName() %&gt;"/&gt;&lt;input type ="text" name = "password" value ="&lt;%=us.getPass()%&gt;"/&gt;&lt;input type="submit" value="确认修改"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; del.jsp123456789101112131415161718192021&lt;%@page import="demo.factory.DaoFactory"%&gt;&lt;%@page import="dao.Dao"%&gt;&lt;%@gupage language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%String path = request.getContextPath();String st = request.getParameter("xx");int id = Integer.parseInt(st);Dao dao = DaoFactory.getDao();;dao.delete(id);response.sendRedirect(path+"/index.jsp");%&gt;&lt;/body&gt;&lt;/html&gt; 重点总结： 需要导入jar包的时候，把用到的包都导入到lib下，不用再buid path 一个页面传参到另一个页面 可以通过form 可以通过session 可以通过get方式的问号传值 一个页面接收参数的时候 String st = request.getParameter(“xx”); 注意返回值类型时String 过滤器启动异常 有可能时jdk版本不同造成的 window.confitm(“弹出的文字”) 返回一个boolean型 一般和if一起用，如果点击确定，则执行if语句 window.location.href=” “ 把当前页面强制跳转到指定地址页面]]></content>
      <categories>
        <category>周末复习</category>
        <category>Java个人笔记</category>
      </categories>
      <tags>
        <tag>Java个人笔记</tag>
        <tag>周末复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filter]]></title>
    <url>%2F2019%2F08%2F10%2F25%2F</url>
    <content type="text"><![CDATA[FilterDebug了一天，直接码吧。 MyFilter.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package demo;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebFilter;/** * Servlet Filter implementation class MyFilter */@WebFilter("/index.jsp")public class MyFilter implements Filter &#123; /** * Default constructor. */ public MyFilter() &#123; // TODO Auto-generated constructor stub &#125; /** * @see Filter#destroy() */ public void destroy() &#123; // TODO Auto-generated method stub System.out.println("销毁"); &#125; /** * @see Filter#doFilter(ServletRequest, ServletResponse, FilterChain) */ public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // TODO Auto-generated method stub // place your code here // pass the request along the filter chain System.out.println("成功过滤"); chain.doFilter(request, response); &#125; /** * @see Filter#init(FilterConfig) */ public void init(FilterConfig fConfig) throws ServletException &#123; // TODO Auto-generated method stub &#125;&#125; web.xml1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;display-name&gt;FilterTest&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;filter&gt; &lt;filter-name&gt;Hello&lt;/filter-name&gt; &lt;filter-class&gt;demo.MyFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;Hello&lt;/filter-name&gt; &lt;url-pattern&gt;/index.jsp&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; index.jsp12345678910111213&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%System.out.println("INDEX"); %&gt;首页&lt;/body&gt;&lt;/html&gt; BUG血的教训！！！ 在xml里配置都正确的前提下，关于启动Tomcat出现过滤器异常的error时，该怎样解决？ 解决方法：项目右键-&gt;properties-&gt;Java Build Path看order and export选项，内容全部打钩，然后点击apply and close（或apply），重新部署启动项目。 （在Libraries选项中可以查看相关jar包是否完整正确） 如果还是不行，则看看lib里面有没有东西，试着把过滤器复制到lib里面 还有可能时jdk版本不一致导致的问题： 1、先设置好jdk,需要确定 项目,eclipse/myeclipse,系统 用的是同一个版本的JDK,例如系统中安装的JDK是1.7,所以把eclipse的jdk成1.7。 2、进入 windows—proferences—java–compiler设置编译出来的文件使用的格式是 1.7版本的 (设置成多少都行,只要兼容,并且与你项目的编译版本一直就可以,我这里统一设置成1.7)。 3、进入项目–properties—java Compiler 把项目编译版本也设置成 1.7 。 4、进入项目–properties—Myeclipse—project Facets设置java文件的版本为 1.7，并打勾。 从以上可以知道如何重新部署一个项目 Filter案例-全站字符编码过滤器HelloYou.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package demo;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet Filter implementation class HelloYou */@WebFilter("/HelloYou")public class HelloYou implements Filter &#123; /** * Default constructor. */ public HelloYou() &#123; // TODO Auto-generated constructor stub &#125; /** * @see Filter#destroy() */ public void destroy() &#123; // TODO Auto-generated method stub System.out.println("销毁"); &#125; /** * @see Filter#doFilter(ServletRequest, ServletResponse, FilterChain) */ public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // TODO Auto-generated method stub // place your code here // pass the request along the filter chain HttpServletRequest rq = (HttpServletRequest)request; HttpServletResponse rp = (HttpServletResponse) response; rq.setCharacterEncoding("UTF-8"); rp.setCharacterEncoding("UTF-8"); rp.setContentType("text/html;charset=UTF-8"); System.out.println("经过过滤"); //放行 chain.doFilter(request, response); &#125; /** * @see Filter#init(FilterConfig) */ public void init(FilterConfig fConfig) throws ServletException &#123; // TODO Auto-generated method stub System.out.println("初始化"); &#125;&#125; web.xml1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;display-name&gt;Hello&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;filter&gt; &lt;filter-name&gt;HelloN&lt;/filter-name&gt; &lt;filter-class&gt;demo.HelloYou&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HelloN&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 重点总结： 放行： doFilter(request,response); 使用request，response时候向下转型 xml里面配置的时需要启动过滤器的条件路径，没在路径里面的页面默认不会启动过滤器]]></content>
      <categories>
        <category>Filter学习</category>
      </categories>
      <tags>
        <tag>Filter学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP检测]]></title>
    <url>%2F2019%2F08%2F08%2F24%2F</url>
    <content type="text"><![CDATA[主页面显示数据库里面的信息（通过表格表示） 主页面的表单的最后一列，有修改和删除两个按钮 点击修改按钮 弹出 确认修改吗？如果确认则跳转到readyChange.jsp页面 readyChange.jsp页面里得到修改记录的信息， readyChange.jsp里面有确认修改按钮.点击确认修改按钮后跳转到Change.jsp Change.jsp页面，首先更新页面里面的内容，然后重定向到首页。 如果点击删除按钮，则弹出一个确认删除的按钮，跳转到del.jsp。 del.jsp里面具体实现删除功能，删除后重定向到首页。 index.jsp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@page import="user.User"%&gt;&lt;%@page import="factory.DaoFactory"%&gt;&lt;%@page import="dao.Dao"%&gt;&lt;%@page import="java.util.ArrayList"%&gt;&lt;%@page import="java.util.List"%&gt;&lt;%String path = request.getContextPath();%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;style type="text/css"&gt;#customers &#123; font-family:"Trebuchet MS", Arial, Helvetica, sans-serif; width:100%; border-collapse:collapse; &#125;#customers td, #customers th &#123; font-size:1em; border:1px solid #98bf21; padding:3px 7px 2px 7px; &#125;#customers th &#123; font-size:1.1em; text-align:left; padding-top:5px; padding-bottom:4px; background-color:#A7C942; color:#ffffff; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;table id="customers"&gt;&lt;tr&gt;&lt;th&gt;ID&lt;/th&gt;&lt;th&gt;NAME&lt;/th&gt;&lt;th&gt;PASS&lt;/th&gt;&lt;th&gt;操作&lt;/th&gt;&lt;/tr&gt;&lt;% Dao dao = DaoFactory.getDao();List&lt;User&gt; list = dao.findAll();for(int i = 0;i&lt;list.size();i++)&#123; User us = list.get(i);%&gt;&lt;tr&gt;&lt;td&gt;&lt;%=us.getId()%&gt;&lt;/td&gt;&lt;td&gt;&lt;%=us.getName()%&gt;&lt;/td&gt;&lt;td&gt;&lt;%=us.getPass()%&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="&lt;%=path%&gt;/readyChange.jsp?uid=&lt;%=us.getId() %&gt;"&gt;&lt;button&gt;修改&lt;/button&gt;&lt;/a&gt;&lt;button onclick ="del(&lt;%=us.getId()%&gt;)"&gt;删除&lt;/button&gt;&lt;/td&gt;&lt;/tr&gt;&lt;% &#125;%&gt;&lt;/table&gt;&lt;script type="text/javascript"&gt;function del(uid)&#123; if(window.confirm("确定要删除吗？"))&#123; window.location.href="&lt;%=path%&gt;/del.jsp?xx="+uid; &#125;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; readyChange.jsp12345678910111213141516171819202122232425262728&lt;%@page import="factory.DaoFactory"%&gt;&lt;%@page import="dao.Dao"%&gt;&lt;%@page import="user.User"%&gt;&lt;%@page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%String path = request.getContextPath(); String uidstr = request.getParameter("uid"); int usrId = Integer.parseInt(uidstr); Dao dao = DaoFactory.getDao(); User us = dao.findUser(usrId);%&gt;修改用户信息&lt;br/&gt;&lt;form action="&lt;%=path%&gt;/Change.jsp" method="post"&gt;ID:&lt;input type="text" readonly="readonly" name="uid" value = "&lt;%=us.getId()%&gt;" /&gt;&lt;br/&gt;Name:&lt;input type="text" name="uname" value="&lt;%=us.getName() %&gt;"/&gt;&lt;br/&gt;Pass:&lt;input type="text" name ="upass" value ="&lt;%=us.getPass() %&gt;"/&gt;&lt;br/&gt;&lt;input type="submit" value="确认修改"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Change.jsp1234567891011121314151617181920212223&lt;%@page import="user.User"%&gt;&lt;%@page import="factory.DaoFactory"%&gt;&lt;%@page import="dao.Dao"%&gt;&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;%request.setCharacterEncoding("UTF-8");response.setCharacterEncoding("UTF-8");String path = request.getContextPath();String uidstr = request.getParameter("uid");int usrId = Integer.parseInt(uidstr);Dao dao = DaoFactory.getDao();String name = request.getParameter("uname");String pass = request.getParameter("upass");User uss = new User();uss.setId(usrId);uss.setName(name);uss.setPass(pass);dao.updateUser(uss);response.sendRedirect(path+"/index.jsp");return;%&gt; del.jsp123456789101112131415&lt;%@page import="user.User"%&gt;&lt;%@page import="factory.DaoFactory"%&gt;&lt;%@page import="dao.Dao"%&gt;&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;%//删除页面,删除后重定向到主页String path = request.getContextPath();String sid = request.getParameter("xx");int id = Integer.parseInt(sid);Dao dao = DaoFactory.getDao();dao.delete(id);response.sendRedirect(path+"/index.jsp");%&gt; 疑难总结： 记得导入包，导包格式 &lt;%@page import = “”%&gt; 要清楚内置对象 &lt;%= %&gt; &lt;% %&gt; &lt;%! %&gt; 12&lt;a href="&lt;%=path%&gt;/readyChange.jsp?uid=&lt;%=us.getId() %&gt;"&gt;&lt;button&gt;修改&lt;/button&gt;&lt;/a&gt; a标签转页面的时候传参要用get传参方式。？uid= 12345678910111213141516171819&lt;% Dao dao = DaoFactory.getDao();List&lt;User&gt; list = dao.findAll();for(int i = 0;i&lt;list.size();i++)&#123; User us = list.get(i);%&gt;&lt;tr&gt;&lt;td&gt;&lt;%=us.getId()%&gt;&lt;/td&gt;&lt;td&gt;&lt;%=us.getName()%&gt;&lt;/td&gt;&lt;td&gt;&lt;%=us.getPass()%&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="&lt;%=path%&gt;/readyChange.jsp?uid=&lt;%=us.getId() %&gt;"&gt;&lt;button&gt;修改&lt;/button&gt;&lt;/a&gt;&lt;button onclick ="del(&lt;%=us.getId()%&gt;)"&gt;删除&lt;/button&gt;&lt;/td&gt;&lt;/tr&gt;&lt;% &#125;%&gt; 可以动态拼接，如上 1234567&lt;script type="text/javascript"&gt;function del(uid)&#123; if(window.confirm("确定要删除吗？"))&#123; window.location.href="&lt;%=path%&gt;/del.jsp?xx="+uid; &#125;&#125;&lt;/script&gt; window.confirm(“内容”) 具有然会值，点击确定按钮返回true window.location.href=””强制跳转页面。 把当前页面强制跳转到目标页面]]></content>
      <categories>
        <category>JSP检测</category>
        <category>Java个人笔记</category>
      </categories>
      <tags>
        <tag>Java个人笔记</tag>
        <tag>JSP检测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP学习]]></title>
    <url>%2F2019%2F08%2F07%2F23%2F</url>
    <content type="text"><![CDATA[JSP运行原理 当JSP页面第一次被请求执行时，Tomcat将启动一个线程将.jsp文件转换成.java文件，再将.java文件转换成.class文件，然后执行.class文件响应客户请求。当该JSP页面再次被执行时，将直接执行字节码文件。JSP标记、Java程序片、表达式等由Tomcat计算并将结果转化为字符串交由浏览器显示。 JSP常用指令格式： &lt;%@ 指令 属性名=”值” %&gt;1.设置页面显示的字符集：&lt;%@ page contentType=”text/html;charset=UTF-8”%&gt;2.在jsp中引入java包：&lt;%@ page import=”java.util.Date”%&gt;3.引入其他页面文件：&lt;%@ include file=“/head.jsp”%&gt; include指令用于引入其它JSP页面，如果使用include指令引入了其它JSP页面，那么JSP引擎将把这两个JSP翻译成一个servlet。所以include指令引入通常也称之为静态引入,其中的file属性用于指定被引入文件的路径。路径以“/”开头，表示代表当前web应用. Java程序片 在 &lt;% %&gt; 之间写Java程序片。一个JSP页面可以有多个JAVA程序片，这些程序片被JSP引擎顺序执行。语法格式如下： &lt;% JAVA程序片 %&gt; 页面局部变量 在程序片中声明的变量称为页面局部变量。页面局部变量在该页面中后续的所有程序片及表达式部分有效。当多个客户请求一个JSP页面时，一个客户的局部变量和另一个客户的局部变量会被分配不同的内存空间。因此，一个客户对页面局部变量的操作结果不影响其它客户的这个局部变量。 成员变量与成员方法 在标记符 &lt;%! %&gt; 内声明成员变量与成员方法。成员变量在整个JSP页面内有效。当多个用户请求同一个JSP页面时，用户共享成员变量。因此每一个用户对成员变量的改动都会影响其它用户。 &lt;%! %&gt;标记中还可以定义方法 成员变量与局部变量 变量的共享性： 成员变量：所有用户共享变量； 页面局部变量：用户间没有联系。变量的初始化： 页面被激活后，成员变量只被初始化一次； 页面被激活后，每次有用户调用，页面局部变量都被初始化。 JSP表达式 在页面上输出信息，语法格式如下： &lt;%= 表达式 %&gt; 表达式的值由服务器计算，并将计算结果以字符串的形式发送到客户端显示。 Java程序片组合可以将Java程序片分成几个小的程序片，以便插入JSP标记或HTML标记，如： 1234567&lt;body&gt; &lt;% for (int i=1;i&lt;=7;i++)&#123; %&gt; &lt;FONT SIZE="&lt;%=i%&gt;"&gt;大家好！&lt;/FONT&gt; &lt;% &#125; %&gt;&lt;/body&gt; JSP页面注释 （1）HTML注释：** （2）JSP注释： &lt;%– 注释内容 –%&gt;（3）Java程序片注释： &lt;% //单行注释 / *多行注释 */ %&gt; 引入其他页面 这两种方式都可以引入其他页面：&lt;%@ include file=“/head.jsp”%&gt;是一个指令元素父页面和包含进来的页面，代码合并后，才一起翻译成servlet，反馈到前台，形成一个HTML页面 &lt;jsp:include page=“head.jsp” /&gt;是一个行为元素父页面和包含进来的页面单独编译，单独翻译成servlet后，在前台拼成一个HTML页面]]></content>
      <categories>
        <category>JSP学习</category>
        <category>Java个人笔记</category>
      </categories>
      <tags>
        <tag>Java个人笔记</tag>
        <tag>JSP学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阶段性检测-1]]></title>
    <url>%2F2019%2F08%2F06%2F22%2F</url>
    <content type="text"><![CDATA[浏览器乱码问题解决1response.setContentType("text/html;charset = UTF-8"); 阶段性检测目标 建立一个个人中心网页（index.jsp） 网站首先检测有无登录（通过Session） 通过网站填写用户账号和密码 服务器和数据库进行连接校验是否匹配。 如果成功则跳转到成功页面，输出个人账号信息（user，pass） 通过请求跳转实现 如果失败则重新跳转到登录页面 通过重定向实现 其中和数据库的连接通过Dao工厂完成 Dao.java1234567package dao;import user.User;public interface Dao &#123;public User findUser(String name,String pass);&#125; User.java1234567891011121314151617181920212223242526package user;public class User &#123;private String name;private String pass;public User(String name, String pass) &#123; this.name = name; this.pass = pass;&#125;public User() &#123; // TODO Auto-generated constructor stub&#125;public String getName() &#123; return name;&#125;public void setName(String name) &#123; this.name = name;&#125;public String getPass() &#123; return pass;&#125;public void setPass(String pass) &#123; this.pass = pass;&#125;&#125; DaoImpl.java1234567891011121314151617181920212223242526272829303132333435363738394041424344package daoimpl;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import dao.Dao;import user.User;import util.JDBCUtil;public class DaoImpl implements Dao&#123; Connection conn = null; PreparedStatement pst = null; String sql = "select * from UN where use=? and pass =?"; ResultSet rs = null;public User findUser(String name,String pass) &#123; try &#123;conn = JDBCUtil.getConnection();pst = conn.prepareStatement(sql);pst.setString(1, name);pst.setString(2, pass);rs = pst.executeQuery(); &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125;if(rs!=null)&#123; try &#123; while(rs.next()) &#123; User user = new User(); user.setName(rs.getString(1)); user.setPass(rs.getString(2)); return user; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125;JDBCUtil.close(conn, pst, rs);return null;&#125;&#125; JDBCUtil.java 通过连接池得到连接对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package util;import java.beans.PropertyVetoException;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import com.mchange.v2.c3p0.ComboPooledDataSource;public class JDBCUtil &#123; public static Connection getConnection() &#123; // TODO Auto-generated method stubComboPooledDataSource cd = new ComboPooledDataSource();try &#123; cd.setDriverClass("oracle.jdbc.driver.OracleDriver"); cd.setJdbcUrl("jdbc:oracle:thin:@//192.168.0.105/orcl"); cd.setUser("liuyanhao"); cd.setPassword("abc123"); try &#123; return cd.getConnection(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; catch (PropertyVetoException e) &#123; // TODO Auto-generated catch block\ System.out.println("获取连接失败"); e.printStackTrace();&#125;return null; &#125; public static void close(Connection c,Statement st,ResultSet rs) &#123; try &#123; if(rs!=null) rs.close(); &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(st!=null) st.close(); &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(c!=null) c.close(); &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; DaoFactory.java1234567891011package factory;import dao.Dao;import daoimpl.DaoImpl;public class DaoFactory &#123;public static Dao getDao()&#123;return new DaoImpl(); &#125;&#125; Index.jsp 这是网站的首页，通过首页提交账号和密码，提交到login 1234567891011121314151617&lt;%@ page language="java" contentType="text/html; charset = UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="/Rethink/Login" method="post"&gt;账号：&lt;input type = "text" value ="" name = "user"/&gt;&lt;br/&gt;密码：&lt;input type ="text" value ="" name="pass"/&gt;&lt;br/&gt;&lt;input type ="submit" value="登录"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Login.java 对提交的账号和密码进行审核，通过与数据库连接实现。如果登录成功，首先通过session存取用户个人信息，然后再跳转请求。失败则重定向到登陆页面。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package demo;import java.io.IOException;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import factory.DaoFactory;import user.User;/** * Servlet implementation class login */@WebServlet("/Login")public class Login extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public Login() &#123; // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("UTF-8"); response.setCharacterEncoding("UTF-8"); HttpSession hs = request.getSession(); String user = (String)request.getParameter("user"); String pass = (String)request.getParameter("pass"); System.out.println(user); System.out.println(pass); User u = DaoFactory.getDao().findUser(user, pass); String url ="/Success"; try &#123; if(u!=null) &#123; //把user存入session hs.setAttribute("user", u); //下面开始跳转-&gt;成功页面 ,请求跳转方式 RequestDispatcher ds = request.getRequestDispatcher(url); ds.forward(request, response); return ; //跳转完页面要结束 &#125;else &#123; //没有在数据库中找到该用户，需要重定向到登陆页面 String root = request.getContextPath(); response.sendRedirect(root+"/index.jsp"); return; &#125; &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doGet(request, response); &#125;&#125; Success.java 登录成功后跳转到的页面，会从session里面取出用户的个人信息并进行输出。 然后可以有一个转到个人中心的选择 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package demo;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import user.User;/** * Servlet implementation class Success */@WebServlet("/Success")public class Success extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public Success() &#123; // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub request.setCharacterEncoding("UTF-8"); response.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); HttpSession hs = request.getSession(); PrintWriter pw = response.getWriter(); User us =(User)hs.getAttribute("user"); String user = us.getName(); String pass = us.getPass(); try &#123; pw.print("&lt;html&gt;&lt;body&gt;账号:"+user+"&lt;br/&gt;密码:"+pass+"&lt;br/&gt;"); String url = request.getContextPath()+"/Person"; pw.print("&lt;a href ='"+url+"'&gt;个人中心&lt;/a&gt;"); pw.print("&lt;/body&gt;&lt;/html&gt;"); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doGet(request, response); &#125;&#125; Person.java 个人中心页面，首先通过session判断用户有没有登录，没登陆则提供一个跳转到登录页面的选择，如果已经登陆了则输出登录信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package demo;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import user.User;/** * Servlet implementation class Person */@WebServlet("/Person")public class Person extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public Person() &#123; // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;//个人中心页面，首先判断用户有没有登录 request.setCharacterEncoding("UTF-8"); response.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); HttpSession hs = request.getSession(); User us =(User)hs.getAttribute("user"); PrintWriter pw = response.getWriter(); if(us!=null) &#123; //证明用户已经登陆 pw.print("&lt;html&gt;&lt;body&gt;账号:"+us.getName()+"&lt;br/&gt;密码:"+us.getPass()+"&lt;br/&gt;"); pw.print("&lt;/body&gt;&lt;/html&gt;"); &#125;else &#123; //证明没有登陆 String url = request.getContextPath()+"/Login"; pw.print("&lt;html&gt;&lt;body&gt;"); pw.print("&lt;a href ='"+url+"'&gt;前往登录&lt;/a&gt;"); pw.print("&lt;/body&gt;&lt;/html&gt;"); &#125; &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doGet(request, response); &#125;&#125; 重点突破 Oracle数据库里面的sql语句，字符串类型数据要用‘ ‘ 从表单里面取出数据: String str = (String)reques.getParameter(“user”); 参数代表表单里面的name 注意从表单里面取数据和从session里面取数据用到的函数的不同 要注意把页面重定位和return结合使用]]></content>
      <categories>
        <category>Java个人笔记</category>
      </categories>
      <tags>
        <tag>Java个人笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周末复习-3]]></title>
    <url>%2F2019%2F08%2F06%2F21%2F</url>
    <content type="text"><![CDATA[在Notepad++中如何快速删除一整行的内容(自定义快捷键) Notepad++是一款免费的文本编辑器，使用的人也是非常的多，尤其是程序员。但在类似eclipse这种软件中，习惯了Ctrl+D删除一整行的操作，到Notepad++中变成了，复制并粘贴一行的操作。开始你或许如我一样以为，肯定有这种快捷键，只是不知道是什么，但是，当你查遍资料之后，你会发现，根本没有这种快捷键。唯一相似的操作是Ctrl+L，但是实际上Crtrl+L是剪切一行，而并非删除一行 网上解决方法： 点击菜单中的【宏】-【开始录制】 鼠标在任意一行内容上单击，使光标停在这行。 然后在键盘上找到home键，按下，这时光标不管之前在哪个位置，现在光标都会出现在这行的最前面，这时按住shift键不松，再在键盘上找到end键然后按下。这时就选中这一行了。然后按两次delete键。 这里有问题，如果要删除的行为一个空白行，就会出现多删除的情况。 然后点击【宏】-【停止录制】。 然后点击【宏】-【保存录制】 然后根据提示，填写名称和选择快捷键的组合，在这我选择的是Ctrl+D。然后点击OK保存。 解决Bug根据以上可能产生的问题：可进行如下方案： 按Home将光标移动到行首位置，然后按Shift+down+Backspace 完美解决！emmm~~ JavaScript复习基础123456789101112131415&lt;html&gt;&lt;head&gt;&lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;for(var a = 1;a&lt;10;a++)&#123;document.write("记录第"+a+"遍&lt;br/&gt;");&#125;for(var a = 1;a&lt;10;a++)&#123;alert("Hello,world!"+"第"+a+"遍");&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 函数变元123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;JS-函数变元&lt;/TITLE&gt; &lt;style&gt;&lt;/style&gt; &lt;/HEAD&gt; &lt;BODY style="height:1500px;" &gt;&lt;div id="a"&gt; &lt;input id="t1" type="text" value="" &gt; &lt;input id="bt" type="button" value="检测" onclick="dian();"&gt;&lt;/div&gt;&lt;div id="b"&gt;&lt;input id="t2" type="text" value="" &gt;&lt;input id="t3" type="hidden" value="XIXI" &gt;&lt;/div&gt; &lt;script&gt;//函数中描述应该有参数，叫做形参function hello(a,b,c)&#123; console.log("HelloWorld:"); console.log(a); console.log(b); console.log(c);&#125;//1,3,5,7,等数值是调用时真实的参数，叫做实参hello(2,3,5,7,9);//思考：js如何做重载呢？//目标：两个参数求和，三个参数求积//JS不支持重载，后定义的function会覆盖前面的function xx(a,b)&#123; console.log("aaaaaaa");&#125;function xx(a,b,c)&#123; console.log("bbbbbbb");&#125;xx(5,6);xx(5,6,7);//JS使用变元机制模拟重载function cz(a,b,c)&#123;//if条件：null,'',undefined,false都为假 if(c!=undefined)&#123;//如果c有值 console.log("至少3个参数:乘法运算="+(a*b*c)); &#125;else if(b)&#123; console.log("有2个参数:加法运算="+(a+b)); &#125;else if(a)&#123; console.log("有1个参数"); &#125;else&#123; console.log("没有参数"); &#125;&#125;cz(5,6,7);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 和表单结合使用12345678910111213141516171819202122232425262728293031323334353637&lt;html&gt;&lt;head&gt;&lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="test" name ="ts" onchange = "alert('值被修改'+this.value);"/&gt;&lt;input type="button" name ="but" value="button" onclick = "dian();"/&gt;&lt;script&gt;function dian()&#123;alert("按钮被点击");&#125;function bianyuan(a,b,c)&#123;if(c)&#123;document.write(a+b+c);&#125;else if(b)&#123;document.write(a+b);&#125;else if(a)&#123;document.write(a);&#125;else&#123;document.write("参数的个数为零个")&#125;&#125;bianyuan(1,2,3);bianyuan(1,2);bianyuan(1);bianyuan();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 利用JavaScript写计时功能12345678910111213141516171819202122232425&lt;html&gt;&lt;head&gt;&lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" value="开始计时" onclick = "jishi();"/&gt; &lt;!--开始计时按钮--&gt; &lt;input type="test" id = "ji" value=""/&gt; &lt;!--记录计时时间--&gt;&lt;input type="button" value="结束计时" onclick = "stop();"/&gt; &lt;!--结束计时按钮--&gt;&lt;script&gt;&lt;!--开始计时函数，可以知道，如果不停止则需要一直计时--&gt;var t;var c = 0;function jishi()&#123;/*首先获得要显示value值，进而给它赋值 */document.getElementById("ji").value = c;c = c+1;t = setTimeout("jishi()",1000);&#125;function stop()&#123; clearTimeout(t);&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 总结 注意函数的参数是变元的。 document.write(“Hello,world”); document.getElementById(“”); onclike = “ “ onchange = “ “ 注意格式 计时器有关 setTimeout（“ ”，1000）;第一个参数是一个语句，第二个参数是执行时间，毫秒为单位，1000毫秒代表1秒。 clearTimeout(t); 注意大小写 JDBC连接池 数据库连接池技术（connection pool）的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。 12345678910111213141516171819202122232425262728293031323334353637import java.beans.PropertyVetoException;import java.sql.Connection;import java.sql.SQLException;import com.mchange.v2.c3p0.ComboPooledDataSource;public class C3p0 &#123; public static void main(String[] args) &#123;ComboPooledDataSource ds = new ComboPooledDataSource();try &#123; //设置驱动 ds.setDriverClass("oracle.jdbc.driver.OracleDriver"); //设置URL ds.setJdbcUrl("jdbc:oracle:thin:@//192.168.0.105/orcl"); //设置用户名 ds.setUser("liuyanhao"); //设置密码 ds.setPassword("abc123"); //设置最大连接数 ds.setMaxPoolSize(40); //设置最小连接数 ds.setMinPoolSize(1); //设置初始连接数 ds.setInitialPoolSize(3); Connection conn = ds.getConnection(); //这里并不是真的关闭了连接，close经过重写，只是将连接归还给连接池 conn.close(); System.out.println("连接数据库成功");&#125; catch (PropertyVetoException e) &#123; e.printStackTrace();&#125; catch (SQLException e) &#123; e.printStackTrace();&#125; &#125;&#125; 重点： 导入C3P0和jdbc的jar包 buid path ComboPooledDataSource com = new ComboPooledDataSource(); com.setDriverClass(“oracle.jdbc.driver.OracleDriver”); 1234567891011ds.setJdbcUrl("jdbc:oracle:thin:@//192.168.0.105/orcl");//设置用户名ds.setUser("liuyanhao");//设置密码ds.setPassword("abc123");//设置最大连接数ds.setMaxPoolSize(40);//设置最小连接数ds.setMinPoolSize(1);//设置初始连接数ds.setInitialPoolSize(3); 两种跳转方式复习MyTest.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package Test;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class MyTest */@WebServlet("/MyTest")public class MyTest extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public MyTest() &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;System.out.println("成功连接网页");request.setCharacterEncoding("UTF-8");response.setCharacterEncoding("UTF-8");String user = "liuyanhao";String pass = "123456";if(user.equals(request.getParameter("user"))&amp;&amp;pass.equals(request.getParameter("pass")))&#123; //请求转发方式，可以传递参数 System.out.println("账户匹配成功！欢迎!"); RequestDispatcher dis = request.getRequestDispatcher("/Success"); dis.forward(request, response); return;&#125;else &#123; //重定向方式 System.out.println("账户匹配失败"); String root = request.getContextPath(); //得到根路径 response.sendRedirect(root+"/error.html"); return; //跳转完页面，程序可以return了已经。 &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; Success.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package Test;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class Success */@WebServlet("/Success")public class Success extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public Success() &#123; &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub System.out.println("登录成功"); request.setCharacterEncoding("UTF-8"); response.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset = UTF-8"); String user = request.getParameter("user"); String pss = request.getParameter("pass"); PrintWriter write = response.getWriter(); write.print("&lt;html&gt;&lt;body&gt;恭喜你，登录成功&lt;br/&gt;账号:"+user+"&lt;br/&gt;密码："+pss+"&lt;/body&gt;&lt;/html&gt;"); write.flush(); write.close(); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doGet(request, response); &#125;&#125; index.jsp123456789101112131415161718192021&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="/ServerTest/MyTest" method = "post"&gt;&lt;input type="test" name ="user" value=""/&gt;账户 &lt;br/&gt;&lt;input type="password" name ="pass"/&gt;密码&lt;br/&gt;&lt;input type="radio" name = "sex" value="nan" /&gt;男&lt;input type = "radio" name = "sex" value = "nv" /&gt;女&lt;br/&gt;&lt;input type = "checkbox" name = "interest" value="movie"/&gt;看电影&lt;input type = "checkbox" name = "interest" value="study"/&gt;学习&lt;input type = "checkbox" name = "interest" value="read"/&gt;读书&lt;br/&gt;&lt;input type="submit" value = "提交"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; error.html12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;您的账号不匹配，请重新登陆&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 总结：有两种跳转方式：重定向，请求跳转 重定向 String root = request.getContextPath(); //得到根路径 response.sendRedirect(root+”/error.html”); //告诉请求页面应该访问的地址 请求跳转 RequestDispatcher dis = request.getRequestDispatcher(“/Success”); dis.forward(request, response); 注意：getRequestDispatcher里面的/代表根路径 Session复习Show.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package demo;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;/** * Servlet implementation class Show */@WebServlet("/Show")public class Show extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public Show() &#123; // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub HttpSession ss = request.getSession(); String str = (String)ss.getAttribute("user"); if(str!=null) &#123; System.out.println(str); &#125;else &#123; System.out.println("null"); &#125; System.out.println(ss.getId()); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doGet(request, response); &#125;&#125; NewTest.java1234567891011121314151617181920212223242526272829303132333435363738394041424344package demo;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;/** * Servlet implementation class NewTest */@WebServlet("/NewTest")public class NewTest extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public NewTest() &#123; // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub HttpSession hs = request.getSession(); hs.setAttribute("user", "liuyanhao"); String id = hs.getId(); System.out.println(id); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doGet(request, response); &#125;&#125; 总结 HttpSession ss = request.getSession(); ss.setAttribute(“user”,”val”); 另一个页面使用时也需要首先通过第一步得到session对象 承上：ss.getAttribute(“user”); 返回值类型为Object类型，需要转型 可以通过调用getId（）方法查两个页面的session是否相同]]></content>
      <categories>
        <category>Java个人笔记</category>
      </categories>
      <tags>
        <tag>Java个人笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周末复习-2]]></title>
    <url>%2F2019%2F08%2F05%2F20%2F</url>
    <content type="text"><![CDATA[Navicat下编写存储过程和函数存储过程12345678910111213create or replaceprocedure PRO_STU //存储过程名(a in number,b in number,c out number //需要输入的参数和输出的参数的声明)AS 或者 IS //如果需要声明变量则用IS 否则用 ASISx integer := 2; //注意sql里面的赋值语句begin select (a+b) into c from dual;end PRO_STU; //注意语句结束后要使用; end 结束后也是 编写SUM函数12345678910111213create or replacefunction FUN_SUM( a in number, b in number)RETURN numberAS 或者 IS //如果需要声明变量则用IS 否则用 ASISx integer := 2; //注意sql里面的赋值语句begin return a+b;end FUN_SUM; //注意语句结束后要使用; end 结束后也是 总结：函数和存储过程相比，开头定义不相同。 函数可以用sql语句调用： select FUN_SUM(10,20) from dual; 使用Navicat对MySql数据库基本操作！对root下的mysql默认数据库不要动，千万不要动。 ！mysql和information_schema不要删除 ！mysql数据库只有数据库管理员才能看到，记录的是数据库的配置信息，很重要，不要乱动 **不作死就不会死** 端口：3306 本地主机：localhost或者127.0.0.1两者是一样的，都代表我的电脑的意思 MySQL中默认用户：root@localhost 初级阶段，对默认用户不要做修改，作为root千万不要取消自己的权限 如何通过网络访问mysql数据库？ 新建一个用户 用户名：lyh 主机： % %代表可以进行网络连接 不要忘记给新创建的用户授权，可以使他拥有一个单独数据库的全部权限 MySql和JDBC连接驱动程序类名：com.mysql.jdbc.Driver JDBC URL: jdbc:mysql://:/ 注意最后使用的是数据库名 Dao工厂设计模式DAO设计模式包含几个重要部分：（1）DAO接口 用来封存方法，用户表面能够看到的（2）DAO实现类 用来实现方法，最底层，用户无法看到（3）DAO工厂类 通过工厂类获取已经实现了的DAO对象（4）实体模型 实体模型对应数据库里面的表的结构类型（5）数据库连接类 这个就是自己写的JDBC工具类 第一步：新建文件夹，导包，build path把依赖的jar包放到新建的文件夹里，这样jar包就会一直和项目联系起来。 如果使用JDBC连接的是MySql数据库，要注意URL的格式： jdbc：mysql：//@92.168.0.105：3306/liuyanhao JDBC工具类代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package myutil;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;//编写JDBC工具类，通过调用工具类可以获取与MySQL数据库的连接public class MyUtil &#123; /* * 第一步：注册驱动类 */ private static String url = "jdbc:mysql://192.168.0.105:3306/liuyanhao"; private static String user ="liuyanhao"; private static String password = "123456"; static &#123; //第一次使用时加载驱动类 try &#123; new com.mysql.jdbc.Driver(); &#125; catch (SQLException e) &#123; System.out.println("加载驱动失败"); e.printStackTrace(); &#125; &#125; //接着获取连接 public static Connection getConnection() &#123; try &#123; Connection conn = DriverManager.getConnection(url, user, password); return conn; &#125; catch (SQLException e) &#123; System.out.println("获取连接失败"); e.printStackTrace(); &#125; return null; &#125; public static void close(Connection conn,Statement st,ResultSet rs) &#123; //关闭连接 try &#123; if(rs!=null) rs.close(); &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(st!=null) st.close(); &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn!=null) conn.close(); &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 第二步：编写DAO接口Dao.java123456789101112131415package dao;import java.util.List;import user.User;public interface Dao &#123; public int save(User user) ; //保存数据到数据库 public int update(User user); //更新数据到数据库 public User find(User user); //通过查找id得到用户 public int delete(int id); //通过查找id从数据库删除数据 //public int delete(String uname,String pass); //通过账户名和密码删除数据 public List&lt;User&gt; findAll(); //查找数据库中的所有数据&#125; 第三步：编写Dao实现类DaoImpl.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package daoImpl;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.ArrayList;import java.util.List;import dao.Dao;import myutil.MyUtil;import user.User;public class DaoImpl implements Dao &#123; @Override public int save(User user) &#123; String sql = "insert into student values(?,?,?); "; PreparedStatement st = null; Connection conn = null; try &#123; conn = MyUtil.getConnection(); st = conn.prepareStatement(sql); st.setInt(1, user.getId()); st.setString(2, user.getuName()); st.setString(3, user.getuPass()); st.execute(); &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; MyUtil.close(conn, st, null); &#125; return 0; &#125; public int update(User user) &#123; String sql ="update student set uName = ?,uPass = ? where id = ?"; PreparedStatement st = null; Connection conn = null; try &#123; conn = MyUtil.getConnection(); st = conn.prepareStatement(sql); st.setString(1,user.getuName()); st.setString(2,user.getuPass()); st.setInt(3, user.getId()); return st.executeUpdate(); &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; MyUtil.close(conn, st, null); &#125; return 0; &#125; public User find(User user)&#123; PreparedStatement st = null; Connection conn = null; ResultSet rs = null; String sql = "select * from student where id = ?"; try &#123; conn = MyUtil.getConnection(); st = conn.prepareStatement(sql); st.setInt(1, user.getId()); rs = st.executeQuery(); while(rs.next()) &#123; User us = new User(); us.setId(rs.getInt(1)); us.setuName(rs.getString(2)); us.setuPass(rs.getString(3)); return us; &#125; &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; MyUtil.close(conn, st, rs); &#125; return null; &#125; public int delete(int id) &#123; String sql ="delete from student where id = ?"; PreparedStatement st = null; Connection conn = null; try &#123; conn = MyUtil.getConnection(); st = conn.prepareStatement(sql); st.setInt(1,id); return st.executeUpdate(); &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; MyUtil.close(conn, st, null); &#125; return 0; &#125; public List&lt;User&gt; findAll()&#123; String sql ="select * from student"; Statement st = null; Connection conn = null; ResultSet rs = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; conn = MyUtil.getConnection(); st = conn.createStatement(); rs = st.executeQuery(sql); while(rs.next()) &#123; User us = new User(); us.setId(rs.getInt(1)); us.setuName(rs.getString(2)); us.setuPass(rs.getString(3)); list.add(us); &#125; return list; &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; MyUtil.close(conn, st, rs); &#125; return null; &#125;&#125; 第四步：编写实体模型User.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package user;//编写实体模型，对应数据库里面表的类型和数据public class User &#123;private String uName;private String uPass;private int id;public User() &#123;&#125;public User(String uName, String uPass, int id) &#123; this.uName = uName; this.uPass = uPass; this.id = id;&#125;public User(String uName, String uPass) &#123; this.uName = uName; this.uPass = uPass; this.id = id;&#125;public User(int id) &#123; this.id = id;&#125;public String getuName() &#123; return uName;&#125;public void setuName(String uName) &#123; this.uName = uName;&#125;public String getuPass() &#123; return uPass;&#125;public void setuPass(String uPass) &#123; this.uPass = uPass;&#125;public int getId() &#123; return id;&#125;public void setId(int id) &#123; this.id = id;&#125;public String toString() &#123; return "id：\t"+getId()+"\t姓名"+getuName()+"\t密码："+getuPass();&#125;&#125; 第五步：编写Dao工厂类DaoFactory.java12345678910package factory;import dao.Dao;import daoImpl.DaoImpl;public class DaoFactory &#123;public static Dao togetDao() &#123; return new DaoImpl();&#125;&#125; Junit测试为了方便进行测试可以，使用新建JUnit Test case来对某一个类进行测试， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package test;import static org.junit.jupiter.api.Assertions.*;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import dao.Dao;import factory.DaoFactory;import user.User;class DaoImplTest &#123; Dao dao = DaoFactory.togetDao(); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); @BeforeEach void setUp() throws Exception &#123; &#125; @Test void testSave() &#123; User user = new User("小明","123456",1); User user1 = new User("小红","123456",2); User user2 = new User("小方","123456",3); try &#123; dao.save(user); dao.save(user1); dao.save(user2); System.out.println("成功存入数据"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Test void testUpdate() &#123; User user = new User("小强","123456",1); try &#123; dao.update(user); System.out.println("成功修改数据"); &#125; catch (Exception e) &#123; e.printStackTrace(); fail("修改数据失败 error"); &#125; &#125; @Test void testFind() &#123; try &#123; User user = new User("小红","123456",2); dao.find(user); System.out.println("成功找到："+user.getuName()); &#125; catch (Exception e) &#123; e.printStackTrace(); fail("查找数据失败 error"); &#125; &#125; @Test void testDelete() &#123; try &#123; dao.delete(3); System.out.println("成功删除"); &#125; catch (Exception e) &#123; e.printStackTrace(); fail("删除数据失败 error"); &#125; &#125; @Test void testFindAll() &#123; list = dao.findAll(); Iterator&lt;User&gt; it = list.iterator(); try &#123; while(it.hasNext()) &#123; User uss = it.next(); try &#123; System.out.println(uss.toString()); &#125;catch(Exception e) &#123; System.out.println("输出所有查询到的数据是失败！"); &#125; &#125; System.out.println("查询所有数据成功"); &#125;catch(Exception e) &#123; System.out.println("查询所有数据失败"); e.printStackTrace(); fail("删除数据失败 error"); &#125; &#125;&#125; 注意： JUnit 4 开始使用 Java 5 中的注解（annotation），常用的几个 annotation 介绍： @BeforeClass：针对所有测试，只执行一次，且必须为static void @Before：初始化方法 @Test：测试方法，在这里可以测试期望异常和超时时间 @After：释放资源 @AfterClass：针对所有测试，只执行一次，且必须为static void @Ignore：忽略的测试方法 一个单元测试用例执行顺序为： @BeforeClass –&gt; @Before –&gt; @Test –&gt; @After –&gt; @AfterClass 每一个测试方法的调用顺序为： @Before –&gt; @Test –&gt; @After MySql删除删除sql语句：delete from 表名 where 条件 注意delete 和 from之间没有*]]></content>
      <categories>
        <category>Java个人笔记</category>
      </categories>
      <tags>
        <tag>Java个人笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周末复习]]></title>
    <url>%2F2019%2F08%2F04%2F19%2F</url>
    <content type="text"><![CDATA[使用Navicat建立数据库的时候，数据库名称一定要全部大写，否则DOS下无法查询那些不是全部大写名称的数据库，以及java连接数据库的时候会出错 注意Navicat中对字符串的操作都是加单引号 JDBC执行SQL语句1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package demo;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class OracleTest &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //注册JDBC驱动 Class.forName("oracle.jdbc.driver.OracleDriver"); //定义连接字符串 String url = "jdbc:oracle:thin:@//192.168.0.105:1521/orcl"; String user ="lyh"; String pass ="123456"; //是驱动管理器与数据库建立连接 Connection conn = null; try &#123; conn = DriverManager.getConnection(url, user, pass); &#125; catch (SQLException e) &#123; System.out.println("与数据库建立连接失败"); e.printStackTrace(); &#125; if(conn != null) &#123; System.out.println("成功与数据库建立连接"); Statement st = conn.createStatement(); ResultSet rs = st.executeQuery("select * from STU"); while(rs.next()) &#123; System.out.println(rs.getString("sname")); &#125;// String ins ="create table student(id int,sname varchar(255),sage int)";// st.execute(ins);// System.out.println("成功创建表");// String inss = "insert into student values(1,'小强',11)";// st.execute(inss);// System.out.println("成功插入数据");// String strr ="select * from student";// rs = st.executeQuery(strr);// while(rs.next()) &#123;// System.out.println(rs.getString("sname"));// &#125; String stn ="insert into STU values(5,'小六',14)"; st.execute(stn); System.out.println("成功插入了表"); rs.close(); st.close(); &#125; conn.close(); &#125;&#125; 特别注意:java里面对sql语句的要求特别严格，稍微不规范就会报错，尤其时String str = “insert into 表名 values（1，‘小明’，11）”的时候 有几点要注意：into后面不用table，最后没有分号，没有！！ 编写JDBC工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package util;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class JDBCUtil &#123;private static String url ="jdbc:oracle:thin:@//192.168.0.105/orcl";private static String user = "lyh";private static String password = "123456";//第一次使用时加载驱动 static &#123; try&#123; new oracle.jdbc.driver.OracleDriver(); &#125;catch(Exception e) &#123; System.out.println("加载驱动失败"); e.printStackTrace(); &#125;&#125;//获取连接public static Connection getConnection() &#123; try &#123; Connection conn = DriverManager.getConnection(url,user,password); return conn;&#125; catch (SQLException e) &#123; System.out.println("获取连接失败"); e.printStackTrace();&#125; return null;&#125;//close（）方法，实现关闭rs,st,connpublic static void close(Connection conn,Statement st,ResultSet rs) &#123; try &#123; if(rs!=null) &#123; rs.close(); &#125; &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(st!=null) &#123; st.close(); &#125; &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn!=null) &#123; conn.close(); &#125; &#125;catch(SQLException e) &#123; e.printStackTrace(); &#125;&#125;&#125; 总结：第一步:注册驱动类；第二步：获取连接；第三步：获取操作对象；第四步：如果需要，建立结果集； 分别对应的类 new.oracle.jdbc.Driver.OracleDriver Connection conn = DriverManager.getConnection(url,user,password); Statement st = conn.createStatement(); ResultSet rs = st.execute(sql); 注意：Oracle的话 Url的形式： jdbc:oracle:thin:@//192.168.0.105/orcl; 另外注意最后的orcl时sid，一般来说就是orcl，除非自己后面修改 关闭的顺序为 rs st conn JDBC编写事务处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package demo;import java.sql.Connection;import java.sql.SQLException;import java.sql.Statement;import util.JDBCUtil;public class Trigger &#123; public static void main(String[] args) &#123;/** * 事务处理 * 第一步：获取连接 * 第二步:获取操作对象 * 第三步：设置不自动提交 */ String sql = "insert into STU values(7,'小明',16)"; Connection conn = JDBCUtil.getConnection(); Statement st = null; try &#123; st = conn.createStatement(); conn.setAutoCommit(false); st.executeUpdate(sql); conn.commit(); //需要自己手动提交 System.out.println("成功插入"); return ; &#125;catch(SQLException e) &#123; //try里面的内容出现了异常，需要回滚 try &#123; System.out.println("插入失败！"); conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125;finally &#123; try &#123; conn.setAutoCommit(true); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; JDBCUtil.close(conn, st, null); &#125; &#125;&#125; 总结：事务处理即成功都成功，失败都失败。 事务处理主要用到try{}catch{}，通过处理异常对事务进行回滚，需要主要的有两个地方 首先把自动提交关了，最后再把自动提交打开 不要忘了，没有问题的话，需要自己手动提交 PreparedStatement 预编译语句1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package demo;import java.beans.Statement;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import util.JDBCUtil;public class Prepare &#123; public static void main(String[] args) &#123;//PrepareStatement 预编译语句 /** * 获得连接 */ String sql ="insert into STU values(?,?,?)"; //特色 Connection conn = JDBCUtil.getConnection(); ResultSet rs = null; PreparedStatement pst = null; try &#123; pst = conn.prepareStatement(sql); pst.setInt(1, 10); //第一个参数是第几个问好 pst.setString(2, "小芳"); //第二个参数是要传的值 pst.setInt(3, 18); pst.addBatch(); pst.executeBatch(); System.out.println("成功插入数据"); //插入成功的话，来看一下里面的数据 // rs = pst.executeQuery("select * from STU"); 不能这么用，需要重新得到一个Statement,应为pst需要绑定变量，即只能用带问号的形式 java.sql.Statement st = conn.createStatement(); rs = st.executeQuery("select * from STU"); System.out.println("学号 姓名 年龄 "); while(rs.next()) &#123; System.out.print(rs.getInt(1)); System.out.print("\t"); System.out.print(rs.getString(2)); System.out.print("\t"); System.out.print(rs.getInt(3)); System.out.print("\n"); &#125; &#125;catch(SQLException e) &#123; System.out.println("插入数据失败"); e.printStackTrace(); &#125;finally &#123; JDBCUtil.close(conn, pst, rs); &#125; &#125;&#125; 总结：PreparedStatement和Statement相比，更加安全，效率更高，性能更好。 要点: PreparedStatement pst = null; ​ pst = conn.PreparedStatement(sql); //注意sql语句的形式 ​ pst.setInt(1,1); ​ pst.setString(2,“”小明”); ​ pst.addBatch(); //需要自己声明一条记录添加完成 ​ pst.executeBatch(); //批操作前面添加的记录]]></content>
      <categories>
        <category>Java个人笔记</category>
      </categories>
      <tags>
        <tag>Java个人笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Navicat下自实现主键自增功能]]></title>
    <url>%2F2019%2F08%2F03%2F18%2F</url>
    <content type="text"><![CDATA[Navicat下自实现主键自增功能通过构建序列和触发器完成 首先构建一个序列 构建触发器 条件写 new. “id” is null 定义语句里面写 12select SEQ_S.nextval into:new."id" from dual;//其中SEQ_S是前面建立的序列的名称 一定要加引号 一定要加引号 一定要加引号]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
      <tags>
        <tag>数据库学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle在DOS下无法管理登录-ORA-01031]]></title>
    <url>%2F2019%2F08%2F03%2F17%2F</url>
    <content type="text"><![CDATA[ORA-01031: insufficient privileges解决办法打开用户组管理输入 lusrmgr.msc 双击ora_dba 点击添加按钮 点击高级按钮 点击立即查找，添加用户（添加用户为本机用户） 成功]]></content>
      <categories>
        <category>BUG分析</category>
      </categories>
      <tags>
        <tag>BUG分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb会话跟踪]]></title>
    <url>%2F2019%2F08%2F02%2F16%2F</url>
    <content type="text"><![CDATA[HTTP通信过程 JavaWeb应用程序运行是基于B/S的模式，用户通过客户端浏览器向Web服务器发送一个HTTP请求，服务器收到请求的同时一个连接就建立了，服务器根据请求做必要的处理并生成一个响应信息，然后把它回送给客户端。这一过程结束后，服务器就关闭了该连接，而不会一直与客户端保持着连接的状态。 HTTP的无状态性 Web服务器需要为大量的用户服务。对于一个服务器，接受一条网络连接就意味着通过一个套接字侦听进入的请求，如果一个服务器同时连接大量的用户，这会消耗掉服务器大量的资源，包括线程和内存。 为了能够服务于大量的用户，HTTP被设计成在每一次新请求中都使用新的连接，这种特性称为HTTP的无状态性。 Session会话 既然http是无状态的，那服务器该如何对多个用户进行区分呢？我们常进的网站通常都是每次只需要登录一次，然后就记住了用户信息和登录状态，这是如何实现的呢？这就需要一种机制来唯一的标识用户，以便跟踪用户在站点中的行为。这就是我们要说的会话对象session，可以利用会话对象session来记录用户的数据信息。 会话的概念 从一个用户打开浏览器并连接到服务器开始到用户关闭浏览器离开这个服务器结束称做一个会话。在多次HTTP连接间维护用户与不同请求之间关联的情况称为维护一个会话（session）当一个用户连接到服务器时可能到不同的页面，而许多WEB程序需要用户在客户端的一系列请求之间能够互相关联，实现不同的页面之间数据的传递和共享，而HTTP协议是无状态的，基于WEB的应用程序需要维护这样的状态，这就需要session，利用session 可以保存访问者访问页面的数据信息 会话的特征 Session是服务器为自己不认识的用户做的标记， Session里面可以存放数据 可以自动创建和销毁 Session工作原理 当用户第一次发出请求时，由WEB容器自动创建一个Session对象，该对象调用相应的方法可以存储用户在访问各个页面其间提交的各种信息，比如名字、号码等信息，同时这个Session 对象被分配了一个唯一的Session ID与之对应。这个Session ID也会随着HTTP响应内容传递给用户端浏览器。传递的方式默认情况下为cookie，如果用户端浏览器关闭了cookie功能，就会使用URL重写技术传递给用户浏览器 在用户发出的后续请求中，请求信息中会包含WEB容器传递给它的Session ID。WEB容器就会根据传回的Session ID寻找用户对应的Session 对象，Session 对象和客户之间是一个一一对应的关系，直到客户关闭浏览器后，服务器才将该用户的Session 对象取消。 Session的ID WEB容器在创建每一个新的HTTP会话对象时，都会赋予一个新的ID号。WEB容器保证它在Web应用范围内是唯一的。这个ID号可以通过Session对象的getId()获得。例如： String sessionId=session.getId(); Session的属性Session对象使用以下方法管理绑定到会话的属性设置：void setAttribute(String name,Object value) ;获取：Object getAttribute(String name);移除：void removeAttribute(String name) ; 与Map的用法相似，其实内部就是键值对。 页面跳转的两种方式： 页面跳转的两种方式： 1.请求转发 服务器内部转发，服务器内部跳转，浏览器无法感知 代码：RequestDispatcher dispatcher = request.getRequestDispatcher(“/hello/show”);dispatcher.forward(request, response); 解释：斜线代表项目根路径,代表WebRoot目录（request.getContextPath）请求转发之后，浏览器中的url不会改变request跳转到下一页面后，还是这个requestrequest可以作为容器使用相当于Map集合request.setAttribute向request中存数据request.getAttribute可以从中取数据 2.重定向 服务器告诉浏览器跳转到某个位置 代码：String path = req.getContextPath();resp.sendRedirect(path+”/MyHtml.html”); 解释：斜线代表服务器根路径重定向最好配合req.getContextPath()使用重定向之后需要结束当前方法重定向之后前面的的请求信息会消失重定向之后浏览器会发起一次新的请求 页面跳转代码示例Myservlet123456789101112131415161718192021222324252627282930313233343536373839404142434445package demo;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet主要功能：接收来自浏览器的请求，给予浏览器响应 * * */public class MyServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("1111111111"); // /** * 重定向 * 斜线代表服务器跟路径 * 重定向之后需要结束当前方法 * 重定向之后之前的请求信息就都没了 * 再一次发起的是新的请求 */ //获取Webroot的URL String path = req.getContextPath(); System.out.println(path); resp.sendRedirect(path+"/MyHtml.html"); return; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; Receive123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package demo;import java.io.IOException;import java.io.PrintWriter;import java.net.HttpRetryException;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Receive extends HttpServlet &#123; /** * The doGet method of the servlet. &lt;br&gt; * * This method is called when a form has its tag value method equals to get. * * @param request the request send by the client to the server * @param response the response send by the server to the client * @throws ServletException if an error occurred * @throws IOException if an error occurred */ public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String xx = request.getParameter("un"); //把表单中的信息提取出来耍耍 System.out.println("Receive1:"+xx); System.out.println("Receive2:"+xx); System.out.println("Receive3:"+xx); //向request中存入数据，带到下一个页面去 request.setAttribute("st", "Hahahaha"); /** * 请求转发 * 斜线代表项目根路径,代表WebRoot目录（request.getContextPath） * 请求转发之后，浏览器中的url不会改变 * request跳转到下一页面后，还是这个request * request可以作为容器使用相当于Map集合 * request.setAttribute向request中存数据 * request.getAttribute可以从中取数据 */ //走起 RequestDispatcher dispatcher = request.getRequestDispatcher("/hello/show"); dispatcher.forward(request, response); return; &#125; /** * The doPost method of the servlet. &lt;br&gt; * * This method is called when a form has its tag value method equals to post. * * @param request the request send by the client to the server * @param response the response send by the server to the client * @throws ServletException if an error occurred * @throws IOException if an error occurred */ public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; Show1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package demo;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Show extends HttpServlet &#123; /** * The doGet method of the servlet. &lt;br&gt; * * This method is called when a form has its tag value method equals to get. * * @param request the request send by the client to the server * @param response the response send by the server to the client * @throws ServletException if an error occurred * @throws IOException if an error occurred */ public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html"); PrintWriter out = response.getWriter(); out.println("&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;"); out.println("&lt;HTML&gt;"); out.println(" &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;"); out.println(" &lt;BODY&gt;"); out.print(" This is "); out.print(this.getClass()); out.println(", using the GET method"); out.println("&lt;br&gt;接到一个表单参数：un="+request.getParameter("un")+",st="+request.getAttribute("st")); out.println(" &lt;/BODY&gt;"); out.println("&lt;/HTML&gt;"); out.flush(); out.close(); &#125; /** * The doPost method of the servlet. &lt;br&gt; * * This method is called when a form has its tag value method equals to post. * * @param request the request send by the client to the server * @param response the response send by the server to the client * @throws ServletException if an error occurred * @throws IOException if an error occurred */ public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; Web.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version="1.0" encoding="UTF-8"?&gt;-&lt;web-app version="3.0" id="WebApp_ID" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;&lt;display-name&gt;页面跳转DEMO&lt;/display-name&gt;-&lt;welcome-file-list&gt;&lt;welcome-file&gt;index.html&lt;/welcome-file&gt;&lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;&lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;&lt;welcome-file&gt;default.html&lt;/welcome-file&gt;&lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;&lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;-&lt;servlet&gt;&lt;servlet-name&gt;hi&lt;/servlet-name&gt;&lt;servlet-class&gt;demo.MyServlet&lt;/servlet-class&gt;&lt;/servlet&gt;-&lt;servlet&gt;&lt;description&gt;This is the description of my J2EE component&lt;/description&gt;&lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt;&lt;servlet-name&gt;Show&lt;/servlet-name&gt;&lt;servlet-class&gt;demo.Show&lt;/servlet-class&gt;&lt;/servlet&gt;-&lt;servlet&gt;&lt;description&gt;This is the description of my J2EE component&lt;/description&gt;&lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt;&lt;servlet-name&gt;Receive&lt;/servlet-name&gt;&lt;servlet-class&gt;demo.Receive&lt;/servlet-class&gt;&lt;/servlet&gt;-&lt;servlet-mapping&gt;&lt;servlet-name&gt;hi&lt;/servlet-name&gt;&lt;url-pattern&gt;/good/haha/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;-&lt;servlet-mapping&gt;&lt;servlet-name&gt;Show&lt;/servlet-name&gt;&lt;url-pattern&gt;/hello/show&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;-&lt;servlet-mapping&gt;&lt;servlet-name&gt;Receive&lt;/servlet-name&gt;&lt;url-pattern&gt;/servlet/Receive&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;/web-app&gt; MyHtml.html (放在WebRoot下)123456789101112131415161718192021&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;MyHtml.html&lt;/title&gt; &lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt; &lt;meta http-equiv="description" content="this is my page"&gt; &lt;meta http-equiv="content-type" content="text/html; charset=UTF-8"&gt; &lt;!--&lt;link rel="stylesheet" type="text/css" href="./styles.css"&gt;--&gt; &lt;/head&gt; &lt;body&gt; This is my HTML page. &lt;br&gt; &lt;form action="./servlet/Receive" method="post"&gt; &lt;input name="un" &gt; &lt;input type="submit" value="提交" &gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Java个人笔记</category>
      </categories>
      <tags>
        <tag>Java个人笔记</tag>
        <tag>JavaWeb会话跟踪</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2F2019%2F08%2F02%2F15%2F</url>
    <content type="text"><![CDATA[Servlet简介 Servlet是用Java语言编写的程序，它运行在Web服务器上，用以处理来自客户端的请求；它一般会把处理的结果以为HTML的形式返回，在客户端形成动态网页 Servlet容器 Servlet和我们以往见过的普通Java类一样，在需要的时候被实例化，在不需要的时候被销毁，而Servlet的实例化和销毁工作由Servlet容器来完成；Servlet在Servlet容器内运行，Servlet容器负责调度Servlet，并控制着Servlet的生命周期；Apache Tomcat既是Web服务器软件，同时也是符合规范的Servlet容器 Javax.servlet.http包中接口 类名称 说 明 HttpServlet 该类是最常用于扩展Servlet的类，因为很多Servlet应用程序都遵照HTTP协议运行。此类支持HTTP协议功能以及Servlet类的方法，它是个抽象类。它接收客户端的请求，并向客户端发送响应。 Cookie 此类用来创建Cookie，它存储了少量由Servlet发送至客户端的信息。 HttpServlet注意事项 HttpServlet中还包含一个service方法，其原型如下： public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException此方法用来调度客户端的请求，API文档中明确规定，请勿重写该方法 http请求方式 HTTP协议定义了GET和POST两种请求方法，POST方法对请求发送的数据量没有限制。Get是使用明文在浏览器地址栏直接显示请求字符串post是将数据隐含在HTTP协议的请求报文中发送至服务器 代码示例 HelloServlet12345678910111213141516171819202122232425//导入必要的包import java.io.*;import javax.servlet.*;import javax.servlet.http.*;//自定义Servlet，继承于HttpServletpublic class HelloServlet extends HttpServlet &#123; //重写父类的doGet方法，收到客户端的请求（get方式）时，执行此方法 public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获得输出流，以便向客户端输出内容 PrintWriter out = response.getWriter(); //向客户端输出页面内容 out.println("&lt;html&gt;"); out.println("&lt;head&gt;"); out.println("&lt;title&gt; HelloServlet &lt;/title&gt;"); out.println("&lt;/head&gt;"); out.println("&lt;body&gt;"); out.println("Hello world!&lt;br&gt;"); out.println("&lt;/body&gt;"); out.println("&lt;/html&gt;"); out.close(); //关闭流 &#125;&#125; Web.xml中配置Servlet12345678910为了使Servlet容器能够正确识别Servlet，还必须在web.xml的配置文件中配置，其格式如下： &lt;servlet&gt; &lt;servlet-name&gt;ServletName&lt;/servlet-name&gt; //servlet名称，名称可以任意命名 &lt;servlet-class&gt;ServletClass&lt;servlet-class&gt;//Servlet类的名称 &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletName&lt;servlet-name&gt;//servlet名称，名称可以任意命名 &lt;url-pattern&gt;ServletURLMapping&lt;url-pattern&gt;//Servlet对应的url名，自己定 &lt;servlet-mapping&gt; Servlet总结 Servlet其实就是运行在服务器端的小应用程序； Servlet容器负责调度Servlet，并控制着它们的生命周期； 一般通过继承HttpServlet的方式来实现Servlet; 根据客户端请求的方式，只需重写doGet或doPost方法即可； 要使容器正确识别Servlet，则必须填写配置文件web.xml； Servlet表单处理Html表单客户端通过浏览器向web服务器提交请求的方式有7种，post、get、 put、 delete、 options 、head和trace,其中只需要掌握get和post就足够了。 Post请求是通过html中的表单(Form)来完成的，表单中包含了若干组件：Input text Input password Input radioInput checkbox select 单选 select 多选TextArea submit reset 123456789表单(Form)&lt;form name=“f1” method=“post” action=“/servlet/check”&gt;&lt;/form&gt;属性：name:表单的名称method:向服务器提交数据的方式，一般get或postaction：表单数据提交的位置( 相对地址或绝对地址) 123456789101112131415161718192021222324252627文本框(text)&lt;input type=“text” name=“userName”Size=“16” maxlength=“8” value=“haha”/&gt;单选按钮(radio)&lt;input type=“radio” name=“gender” value=“nan” checked&gt;男&lt;input type=“radio” name=“gender” value=“nv” &gt;女复选按钮(checkbox)&lt;input type=“checkbox” name=“interest” value=“movie”&gt;看电影&lt;input type=“checkbox” name=“interest” value=“computer”&gt;玩电脑&lt;input type=“checkbox” name=“interest” value=“shopping”&gt;购物下拉列表(select 单选)&lt;select name=“city”&gt; &lt;option value=“beijing”&gt;北京&lt;/option&gt; &lt;option value=“shanghai”&gt;上海&lt;/option&gt; &lt;option value=“wuxi”&gt;无锡&lt;/option&gt; &lt;option value=“dalian”&gt;大连&lt;/option&gt; &lt;option value=“etc”&gt;其他&lt;/option&gt;&lt;/select&gt;文本域(TextArea)&lt;textarea name=“comment” rows=“10” cols=“40”&gt;感谢使用本系统&lt;/textarea&gt;提交按钮(submit)和重置按钮(reset)&lt;input type=“submit” value=“提交”/&gt;&lt;input type=“reset” value=“重置”/&gt; HttpServletRequest常用方法 获取单值请求参数的方法：getParamter(); 获取多值请求参数的方法：getParameterValues(); 获取请求参数名字的方法：getParameterNames(); 获取session对象的方法：getSession(); 获取Web应用根路径的方法：getContextPath(); 获取Servlet路径的方法：getServletPath(); 获取request中的属性的方法：getAttribute(); 设置request中的属性的方法：setAttribute(); 获取请求转发对象的方法：getRequestDispatcher(); Html传值方式1234567891011想把un=tom和pw=123传到服务器上的login.jsp，可以采用如下方法：post:&lt;form method=“post” action=“login.jsp”&gt;&lt;input name=“un” value=“tom” /&gt;&lt;input name=“pw” value=“123” /&gt;&lt;input tupe=“submit” value=“Login” /&gt;&lt;/form&gt;get:http://xxxx/login.jsp?un=tom&amp;pw=123 页面重定向（1）1.客户端跳转res.sendRedirect(“index.jsp”) 页面重定向（2）1.服务器跳转RequestDispatcher dispatcher = req.getRequestDispatcher(“hehe.jsp”); dispatcher.forward(req, resp); 两种跳转方式对比 1.服务器跳转RequestDispatcher dispatcher = req.getRequestDispatcher(“hehe.jsp”); dispatcher.forward(req, resp);在服务端进行重新指向，可以将request中的参数继续传递到下一个页面。 2.客户端跳转response.sendRedirect(“index.jsp”);让客户端跳转到指定页面，会让浏览器重新发起请求，所以无法将原request中的参数继续传递。 乱码问题response乱码浏览器乱码：浏览器中显示的内容都是从服务器传出的数据，出现乱码的原因就是浏览器的显示编码和数据编码不一致 让它们一致就可以了：response.setContentType(“text/html; charset=utf-8”);response.setCharacterEncoding(“UTF-8”); request-post乱码request请求分为post和get，对于不同的请求方式有不同的解决乱码的方案： POST解决方案:设置request的编码与提交请求的页面编码相同。setCharacterEncoding只对post有效。 request.setCharacterEncoding(“UTF-8”); request-get乱码request请求分为post和get，对于不同的请求方式有不同的解决乱码的方案： GET解决方案: //用ISO-8859-1编码读出数据，再转为UTF8String name=req.getParameter(“usrname”);String name2=new String(name.getBytes(“ISO-8859-1”), “UTF-8”); 其中ISO8859-1与浏览器内部编码一致，UTF-8是我们需要的编码。 实例代码MyServlet123456789101112131415161718192021222324252627282930313233package demo;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet主要功能：接收来自浏览器的请求，给予浏览器响应 * @author * */public class MyServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding("UTF-8"); System.out.println("服务器接到Get请求"); resp.getWriter().print("&lt;html&gt;&lt;body&gt;&lt;h1&gt;HelloWorld世界你好&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("服务器接到Post请求"); doGet(req, resp); &#125;&#125; Zhuce123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package demo;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Zhuce extends HttpServlet &#123; /** * The doGet method of the servlet. &lt;br&gt; * * This method is called when a form has its tag value method equals to get. * * @param request the request send by the client to the server * @param response the response send by the server to the client * @throws ServletException if an error occurred * @throws IOException if an error occurred */ public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("UTF-8"); //设置request编码 response.setCharacterEncoding("UTF-8"); //设置response编码 String a = request.getParameter("userName"); System.out.println("接到用户名："+a); System.out.println("性别："+request.getParameter("sex")); String[] ins = request.getParameterValues("interest"); for(String str : ins)&#123; System.out.println("兴趣："+str); &#125; System.out.println("城市："+request.getParameter("city")); &#125; /** * The doPost method of the servlet. &lt;br&gt; * * This method is called when a form has its tag value method equals to post. * * @param request the request send by the client to the server * @param response the response send by the server to the client * @throws ServletException if an error occurred * @throws IOException if an error occurred */ public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; Web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="UTF-8"?&gt;-&lt;web-app version="3.0" id="WebApp_ID" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;&lt;display-name&gt;HelloServlet&lt;/display-name&gt;-&lt;welcome-file-list&gt;&lt;welcome-file&gt;index.html&lt;/welcome-file&gt;&lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;&lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;&lt;welcome-file&gt;default.html&lt;/welcome-file&gt;&lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;&lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;-&lt;servlet&gt;&lt;servlet-name&gt;hehe&lt;/servlet-name&gt;&lt;servlet-class&gt;demo.MyServlet&lt;/servlet-class&gt;&lt;/servlet&gt;-&lt;servlet&gt;&lt;description&gt;This is the description of my J2EE component&lt;/description&gt;&lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt;&lt;servlet-name&gt;Zhuce&lt;/servlet-name&gt;&lt;servlet-class&gt;demo.Zhuce&lt;/servlet-class&gt;&lt;/servlet&gt;-&lt;servlet-mapping&gt;&lt;servlet-name&gt;hehe&lt;/servlet-name&gt;&lt;url-pattern&gt;/hh/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;-&lt;servlet-mapping&gt;&lt;servlet-name&gt;Zhuce&lt;/servlet-name&gt;&lt;url-pattern&gt;/xixi/haha/register.php&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;/web-app&gt; index.jsp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;title&gt;My JSP 'index.jsp' starting page&lt;/title&gt; &lt;meta http-equiv="pragma" content="no-cache"&gt; &lt;meta http-equiv="cache-control" content="no-cache"&gt; &lt;meta http-equiv="expires" content="0"&gt; &lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt; &lt;meta http-equiv="description" content="This is my page"&gt; &lt;!-- &lt;link rel="stylesheet" type="text/css" href="styles.css"&gt; --&gt; &lt;/head&gt; &lt;body&gt; This is my JSP page. &lt;br&gt; &lt;form action="./xixi/haha/register.php" method="post"&gt; &lt;input type="text" name="userName" /&gt; &lt;br&gt; &lt;input type="radio" name="sex" value="nan" checked&gt;男 &lt;input type="radio" name="sex" value="nv" &gt;女 &lt;br&gt; &lt;input type="checkbox" name="interest" value="movie"&gt;看电视&lt;input type="checkbox" name="interest" value="computer"&gt;玩电脑&lt;input type="checkbox" name="interest" value="shopping"&gt;购物&lt;br&gt;&lt;select name="city"&gt; &lt;option value="beijing"&gt;北京&lt;/option&gt; &lt;option value="shanghai"&gt;上海&lt;/option&gt; &lt;option value="wuxi"&gt;无锡&lt;/option&gt; &lt;option value="dalian"&gt;大连&lt;/option&gt; &lt;option value="etc"&gt;其他&lt;/option&gt;&lt;/select&gt;&lt;br&gt;&lt;textarea name="comment" rows="10" cols="40"&gt;感谢使用本系统&lt;/textarea&gt;&lt;br&gt; &lt;input type="submit" value="提交"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Java个人笔记</category>
      </categories>
      <tags>
        <tag>Java个人笔记</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb服务器-Tomcat]]></title>
    <url>%2F2019%2F08%2F02%2F14%2F</url>
    <content type="text"><![CDATA[Http详解 引言HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。HTTP协议的主要特点可概括如下：1.支持客户/服务器模式。2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 一、HTTP协议详解之URL篇 http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。HTTP URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下：http://host[&quot;:&quot;port][abs_path]http表示要通过HTTP协议来定位网络资源；host表示合法的Internet主机域名或者IP地址；port指定一个端口号，为空则使用缺省端口80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。eg:1、输入：www.guet.edu.cn浏览器自动转换成：http://www.guet.edu.cn/2、http:192.168.0.116:8080/index.jsp 二、HTTP协议详解之请求篇 http请求由三部分组成，分别是：请求行、消息报头、请求正文1、请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。请求方法（所有方法全为大写）有多种，各个方法的解释如下：GET 请求获取Request-URI所标识的资源POST 在Request-URI所标识的资源后附加新的数据HEAD 请求获取由Request-URI所标识的资源的响应消息报头PUT 请求服务器存储一个资源，并用Request-URI作为其标识DELETE 请求服务器删除Request-URI所标识的资源TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断CONNECT 保留将来使用OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求应用举例：GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源，eg:GET /form.html HTTP/1.1 (CRLF)POST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。eg：POST /reg.jsp HTTP/ (CRLF)Accept:image/gif,image/x-xbit,… (CRLF)…HOST:www.guet.edu.cn (CRLF)Content-Length:22 (CRLF)Connection:Keep-Alive (CRLF)Cache-Control:no-cache (CRLF)(CRLF) //该CRLF表示消息报头已经结束，在此之前为消息报头user=jeffrey&amp;pwd=1234 //此行以下为提交的数据HEAD方法与GET方法几乎是一样的，对于HEAD请求的回应部分来说，它的HTTP头部中包含的信息与通过GET请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到Request-URI所标识的资源的信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。2、请求报头后述3、请求正文(略) 三、HTTP协议详解之响应篇 在接收和解释请求消息后，服务器返回一个HTTP响应消息。HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文1、状态行格式如下：HTTP-Version Status-Code Reason-Phrase CRLF其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求常见状态代码、状态描述、说明：200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常eg：HTTP/1.1 200 OK （CRLF）2、响应报头后述3、响应正文就是服务器返回的资源的内容 四、HTTP协议详解之消息报头篇 HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。1、普通报头在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。eg：Cache-Control 用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.eg：为了指示IE浏览器（客户端）不要缓存页面，服务器端的JSP程序可以编写如下：response.sehHeader(“Cache-Control”,”no-cache”);//response.setHeader(“Pragma”,”no-cache”);作用相当于上述代码，通常两者//合用这句代码将在发送的响应消息中设置普通报头域：Cache-Control:no-cache Date普通报头域表示消息产生的日期和时间Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接2、请求报头请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。常用的请求报头AcceptAccept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。Accept-CharsetAccept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。Accept-EncodingAccept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。Accept-LanguageAccept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。AuthorizationAuthorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。Host（发送请求时，该报头域是必需的）Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg：我们在浏览器中输入：http://www.guet.edu.cn/index.html浏览器发送的请求消息中，就会包含Host请求报头域，如下：Host：www.guet.edu.cn此处使用缺省端口号80，若指定了端口号，则变成：Host：www.guet.edu.cn:指定端口号User-Agent我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。请求报头举例：GET /form.html HTTP/1.1 (CRLF)Accept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,/ (CRLF)Accept-Language:zh-cn (CRLF)Accept-Encoding:gzip,deflate (CRLF)If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)If-None-Match:W/“80b1a4c018f3c41:8317” (CRLF)User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)Host:www.guet.edu.cn (CRLF)Connection:Keep-Alive (CRLF)(CRLF)3、响应报头响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。常用的响应报头LocationLocation响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。ServerServer响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。下面是Server响应报头域的一个例子：Server：Apache-Coyote/1.1WWW-AuthenticateWWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。eg：WWW-Authenticate:Basic realm=”Basic Auth Test!” //可以看出服务器对请求资源采用的是基本验证机制。 4、实体报头请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。常用的实体报头Content-EncodingContent-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content-Encoding：gzipContent-LanguageContent-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读者。eg：Content-Language:daContent-LengthContent-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。Content-TypeContent-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。eg：Content-Type:text/html;charset=ISO-8859-1Content-Type:text/html;charset=GB2312Last-ModifiedLast-Modified实体报头域用于指示资源的最后修改日期和时间。ExpiresExpires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。eg：Expires：Thu，15 Sep 2006 16:23:12 GMTHTTP1.1的客户端和缓存必须将其他非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0，jsp中程序如下：response.setDateHeader(“Expires”,”0”); 五、利用telnet观察http协议的通讯过程 实验目的及原理： 利用MS的telnet工具，通过手动输入http请求信息的方式，向服务器发出请求，服务器接收、解释和接受请求后，会返回一个响应，该响应会在telnet窗口上显示出来，从而从感性上加深对http协议的通讯过程的认识。 实验步骤：1、打开telnet1.1 打开telnet运行–&gt;cmd–&gt;telnet1.2 打开telnet回显功能set localecho2、连接服务器并发送请求2.1 open www.guet.edu.cn 80 //注意端口号不能省略 HEAD /index.asp HTTP/1.0 Host:www.guet.edu.cn /我们可以变换请求方法,请求桂林电子主页内容,输入消息如下/ open www.guet.edu.cn 80 GET /index.asp HTTP/1.0 //请求资源的内容 Host:www.guet.edu.cn 2.2 open www.sina.com.cn 80 //在命令提示符号下直接输入telnet www.sina.com.cn 80 HEAD /index.asp HTTP/1.0 Host:www.sina.com.cn 3 实验结果：3.1 请求信息2.1得到的响应是:HTTP/1.1 200 OK //请求成功Server: Microsoft-IIS/5.0 //web服务器Date: Thu,08 Mar 200707:17:51 GMTConnection: Keep-AliveContent-Length: 23330Content-Type: text/htmlExpries: Thu,08 Mar 2007 07:16:51 GMTSet-Cookie: ASPSESSIONIDQAQBQQQB=BEJCDGKADEDJKLKKAJEOIMMH; path=/Cache-control: private//资源内容省略3.2 请求信息2.2得到的响应是:HTTP/1.0 404 Not Found //请求失败Date: Thu, 08 Mar 2007 07:50:50 GMTServer: Apache/2.0.54 Last-Modified: Thu, 30 Nov 2006 11:35:41 GMTETag: “6277a-415-e7c76980”Accept-Ranges: bytesX-Powered-By: mod_xlayout_jh/0.0.1vhs.markII.remixVary: Accept-EncodingContent-Type: text/htmlX-Cache: MISS from zjm152-78.sina.com.cnVia: 1.0 zjm152-78.sina.com.cn:80&lt;squid/2.6.STABLES-20061207&gt;X-Cache: MISS from th-143.sina.com.cnConnection: close 失去了跟主机的连接按任意键继续…4 .注意事项：1、出现输入错误，则请求不会成功。 2、报头域不分大小写。 3、更深一步了解HTTP协议，可以查看RFC2616，在http://www.letf.org/rfc上找到该文件。 4、开发后台程序必须掌握http协议六、HTTP协议相关技术补充 1、基础： 高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等中介由三种：代理(Proxy)、网关(Gateway)和通道(Tunnel)，一个代理根据URI的绝对格式来接受请求，重写全部或部分消息，通过 URI的标识把已格式化过的请求发送到服务器。网关是一个接收代理，作为一些其它服务器的上层，并且如果必须的话，可以把请求翻译给下层的服务器协议。一 个通道作为不改变消息的两个连接之间的中继点。当通讯需要通过一个中介(例如：防火墙等)或者是中介不能识别消息的内容时，通道经常被使用。 代理(Proxy)：一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的 服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处 理没有被用户代理完成的请求。网关(Gateway)：一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。 通道(Tunnel)：是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继 的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。 2、协议分析的优势—HTTP分析器检测网络攻击以模块化的方式对高层协议进行分析处理，将是未来入侵检测的方向。HTTP及其代理的常用端口80、3128和8080在network部分用port标签进行了规定 3、HTTP协议Content Lenth限制漏洞导致拒绝服务攻击使用POST方法时，可以设置ContentLenth来定义需要传送的数据长度，例如ContentLenth:999999999，在传送完成前，内 存不会释放，攻击者可以利用这个缺陷，连续向WEB服务器发送垃圾数据直至WEB服务器内存耗尽。这种攻击方法基本不会留下痕迹。http://www.cnpaf.net/Class/HTTP/0532918532667330.html 4、利用HTTP协议的特性进行拒绝服务攻击的一些构思服务器端忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求（毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来，服务器失去响应，这种情况我们称作：服务器端受到了SYNFlood攻击（SYN洪水攻击）。而Smurf、TearDrop等是利用ICMP报文来Flood和IP碎片攻击的。本文用“正常连接”的方法来产生拒绝服务攻击。19端口在早期已经有人用来做Chargen攻击了，即Chargen_Denial_of_Service，但是！他们用的方法是在两台Chargen 服务器之间产生UDP连接，让服务器处理过多信息而DOWN掉，那么，干掉一台WEB服务器的条件就必须有2个：1.有Chargen服务2.有HTTP 服务方法：攻击者伪造源IP给N台Chargen发送连接请求（Connect），Chargen接收到连接后就会返回每秒72字节的字符流（实际上根据网络实际情况，这个速度更快）给服务器。 5、Http指纹识别技术 Http指纹识别的原理大致上也是相同的：记录不同服务器对Http协议执行中的微小差别进行识别.Http指纹识别比TCP/IP堆栈指纹识别复杂许 多,理由是定制Http服务器的配置文件、增加插件或组件使得更改Http的响应信息变的很容易,这样使得识别变的困难；然而定制TCP/IP堆栈的行为 需要对核心层进行修改,所以就容易识别. 要让服务器返回不同的Banner信息的设置是很简单的,象Apache这样的开放源代码的Http服务器,用户可以在源代码里修改Banner信息,然 后重起Http服务就生效了；对于没有公开源代码的Http服务器比如微软的IIS或者是Netscape,可以在存放Banner信息的Dll文件中修 改,相关的文章有讨论的,这里不再赘述,当然这样的修改的效果还是不错的.另外一种模糊Banner信息的方法是使用插件。常用测试请求：1：HEAD/Http/1.0发送基本的Http请求2：DELETE/Http/1.0发送那些不被允许的请求,比如Delete请求3：GET/Http/3.0发送一个非法版本的Http协议请求4：GET/JUNK/1.0发送一个不正确规格的Http协议请求Http指纹识别工具Httprint,它通过运用统计学原理,组合模糊的逻辑学技术,能很有效的确定Http服务器的类型.它可以被用来收集和分析不同Http服务器产生的签名。 6、其他：为了提高用户使用浏览器时的性能，现代浏览器还支持并发的访问方式，浏览一个网页时同时建立多个连接，以迅速获得一个网页上的多个图标，这样能更快速完成整个网页的传输。HTTP1.1中提供了这种持续连接的方式，而下一代HTTP协议：HTTP-NG更增加了有关会话控制、丰富的内容协商等方式的支持，来提供更高效率的连接。 Java Web服务器-TomcatCS/BS对比 类型 Web应用 桌面应用 优点 1.标准化的开发，发布和浏览方式2.客户机不需要安装专门的客户程序，只要安装浏览器即可3.软件升级容易4.易于在异构平台上进行配置集成5.降低对用户的培训费用 1.交互性好 2.运行性能好 3.网络负载小 4.非常安全 5.易于维护和跟踪用户的状态 缺点 1.客户界面开发不如桌面应用程序方便，难以实现复杂的客户界面。2.响应速度慢，难以满足实时系统的需求。 1.系统整合型差2.配置和维护成本高3.对客户机的要求高4.用户培训时间长5.软件伸缩性差6.软件复用性差 Tomcat安装包 Tomcat官方站点：http://tomcat.apache.org获取Tomcat安装程序包 tar.gz文件是Linux操作系统下的安装版本 exe文件是Windows系统下的安装版本 zip文件是Windows系统下的压缩版本 启动Tomcat 安装版方法1：使用Tomcat服务程序方法2：使用Tomcat程序组中的快捷菜单方法3：使用Tomcat.exe程序 解压版：使用批处理程序，执行bin目录中的startup.bat 访问Tomcat 启动Tomcat后，访问 http://localhost:8080/显示界面代表安装成功 常见问题 1.JAVA_HOME环境变量：解压版在启动Tomcat时需要用到JAVA_HOME环境变量 2.端口号被占用：打开conf下的server.xml，修改服务端口 发布自己的html 把写好的html页面放到webapps中，启动Tomcat，别人就可以使用浏览器通过网络访问了。 Eclipse中配置Web服务器 想要在Eclipse中调试web程序，必须要有Web服务器，所以我们需要在Eclipse中配置Tomcat。 建立并发布JavaWeb应用 建立一个web应用发布JavaWeb应用(开放式目录和war 代码实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package web.server;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.net.ServerSocket;import java.net.Socket;/** * 不是在做服务器 * 只是解释，服务器的原理 * * HTTP协议是应用层协议，基于TCP/IP协议实现 * @author Charles * */public class MyServer &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ser = new ServerSocket(5678); while(true)&#123; System.out.println("服务端对象准备就绪，等待连接..."); final Socket sc = ser.accept(); new Thread()&#123; public void run() &#123; try &#123; System.out.println("有客户连入"); InputStream in = new ileInputStream("c:/abc/05-返回顶部后回调函数.html"); OutputStream out = sc.getOutputStream(); byte[] bs = new byte[1024*64]; for(int len=0;(len=in.read(bs))!=-1;)&#123; out.write(bs,0,len); &#125; out.close(); in.close(); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125;; &#125;.start(); &#125; &#125; &#125; 概念 WEB:网页，许多网页就组成了网站WEB服务器：支持WEB访问服务的一个电脑WEB服务端程序：是一款软件，可以监听某个端口，等待其他人的浏览器来访问，然后把我们写好的页面内容发送过去 JavaWeb：使用Java程序开发的网站JavaWeb服务器：支持java语言的Web服务器 PHPweb：支持php语言的Web服务器 DotNetWeb：支持.NET语言的Web服务器 WEB是基于网络的，遵循HTTP协议，默认端口：80]]></content>
      <categories>
        <category>JavaWeb服务器-Tomcat</category>
      </categories>
      <tags>
        <tag>JavaWeb服务器-Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web学习-2]]></title>
    <url>%2F2019%2F07%2F27%2F13%2F</url>
    <content type="text"><![CDATA[JavaScriptJavaScript概念 JavaScript是由Netscape公司开发，介于Java与HTML之间、基于对象事件驱动的编程语言，已经受到全球的关注。因它的开发环境简单，不需要Java编译器，而是直接运行在Web浏览器中，而因倍受Web设计者的欢迎。JavaScript的出现，它可以使得信息和用户之间不仅只是一种显示和浏览的关系，而是实现了一种实时的、动态的、可交式的表达能力 JavaScript特点 脚本编写语言 基于对象的语言 简单性 安全性 动态性 跨平台性 JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的软件。它本身提供了非常丰富的内部对象供设计人员使用，因而说它是一种基于对象（Object Based）和事件驱动（Event Driver）的编程语言。 JavaScript是一种解释性编程语言，其源代码在发往客户端执行之前不需经过编译，而是将文本格式的字符代码发送给客户编由浏览器解释执行。 JavaScript中变量声明，采用其弱类型。即变量在使用前不需作声明，而是解释器在运行时检查其数据类型，如： x=1234; y＝”4321”; 前者说明x为其数值型变量，而后者说明y为字符型变量。 JavaScript程序构成 控制语句 函数 对象 方法 属性 JS - HelloWorld12345678&lt;html&gt;&lt;body&gt;&lt;script type="text/javascript"&gt;document.write("Hello World!");alert("Hello World");&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JS – 函数 Function 函数名 （参数,变元）{ 函数体;. Return 表达式; } 说明： 当调用函数时,所用变量或字面量均可作为变元传递。 函数由关键字Function定义。 函数名：定义自己函数的名字。 参数表，是传递给函数使用或操作的值，其值可以是常量 ，变量或其它表达式。 通过指定函数名（实参）来调用一个函数。 必须使用Return将值返回。 函数名对大小写是敏感的。 JS – 事件驱动及事件处理 JavaScript是基于对象(object-based)的语言，基于对象的基本特征，就是采用事件驱动(event-driven)。通常鼠标或键盘的动作我们称之为事件（Event），而由事件引发的程序的动作，称之为事件驱动（Event Driver）。对事件进行处理的程序或函数，我们称之为事件处理程序（Event Handler） 事件处理程序在JavaScript中对象事件的处理通常由函数(Function)担任。其实就是在事件中调用函数。 主要有以下几个事件 单击事件onClick onChange改变事件 选中事件onSelect 获得焦点事件onFocus 失去焦点onBlur 载入文件onLoad 卸载文件onUnload Onchange演示12345678&lt;html&gt;&lt;body&gt;&lt;script&gt;function checkmail()&#123;alert("修改了");&#125;&lt;input type="text" size="30" id="email" onchange="checkmail()"/&gt;&lt;/body&gt;&lt;/html&gt; 实战演习JS-函数123456789101112131415161718192021222324252627282930313233343536&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;JS-函数&lt;/TITLE&gt; &lt;style&gt;&lt;/style&gt; &lt;/HEAD&gt; &lt;BODY style="height:1500px;" &gt; &lt;script&gt;//定义函数function hello()&#123; alert("HelloWorld");&#125;function say(hua)&#123; alert(hua);&#125;function cheng(a,b)&#123; return a*b;&#125;//调用函数hello();say("世界你好");var result = cheng(6,7);document.write("结果："+result);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JS-事件处理123456789101112131415161718192021222324&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;JS-函数&lt;/TITLE&gt; &lt;style&gt;&lt;/style&gt; &lt;/HEAD&gt; &lt;BODY style="height:1500px;" &gt; &lt;input type="text" value="" onchange="alert('值被改变'+this.value);"&gt; &lt;input type="button" value="点这里..." onclick="dian();"&gt; &lt;script&gt;function dian()&#123; alert("按钮被点击"); window.location&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JS-查找DOM节点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;JS-查找DOM节点&lt;/TITLE&gt; &lt;style&gt;&lt;/style&gt; &lt;/HEAD&gt; &lt;BODY style="height:1500px;" &gt;&lt;div id="a"&gt; &lt;input id="t1" type="text" value="" &gt; &lt;input id="bt" type="button" value="检测" onclick="dian();"&gt;&lt;/div&gt;&lt;div id="b"&gt;&lt;input id="t2" type="text" value="" &gt;&lt;input id="t3" type="hidden" value="XIXI" &gt;&lt;/div&gt; &lt;script&gt;function dian()&#123; //调用document对象的函数，查找id为t的元素所对应的DOM对象 var el = document.getElementById('t'); alert(el.value);&#125;//所有input元素的集合var ins = document.getElementsByTagName("input");for(var i=0;i&lt;ins.length;i++)&#123; var el = ins[i]; //alert(el.id);&#125;//查找b节点下的input集合var ins = document.getElementById('b').getElementsByTagName("input");for(var i=0;i&lt;ins.length;i++)&#123; var el = ins[i]; //alert(el.id);&#125;//查找t2父亲的最后一个孩子，实验发现：DIV中会把换行当做节点，所以一个DIV需要写成一行var x = document.getElementById("t2").parentNode.lastChild;console.log(x);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JS-函数变元123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;JS-函数变元&lt;/TITLE&gt; &lt;style&gt;&lt;/style&gt; &lt;/HEAD&gt; &lt;BODY style="height:1500px;" &gt;&lt;div id="a"&gt; &lt;input id="t1" type="text" value="" &gt; &lt;input id="bt" type="button" value="检测" onclick="dian();"&gt;&lt;/div&gt;&lt;div id="b"&gt;&lt;input id="t2" type="text" value="" &gt;&lt;input id="t3" type="hidden" value="XIXI" &gt;&lt;/div&gt; &lt;script&gt;//函数中描述应该有参数，叫做形参function hello(a,b,c)&#123; console.log("HelloWorld:"); console.log(a); console.log(b); console.log(c);&#125;//1,3,5,7,等数值是调用时真实的参数，叫做实参hello(2,3,5,7,9);//思考：js如何做重载呢？//目标：两个参数求和，三个参数求积//JS不支持重载，后定义的function会覆盖前面的function xx(a,b)&#123; console.log("aaaaaaa");&#125;function xx(a,b,c)&#123; console.log("bbbbbbb");&#125;xx(5,6);xx(5,6,7);//JS使用变元机制模拟重载function cz(a,b,c)&#123;//if条件：null,'',undefined,false都为假 if(c!=undefined)&#123;//如果c有值 console.log("至少3个参数:乘法运算="+(a*b*c)); &#125;else if(b)&#123; console.log("有2个参数:加法运算="+(a+b)); &#125;else if(a)&#123; console.log("有1个参数"); &#125;else&#123; console.log("没有参数"); &#125;&#125;cz(5,6,7);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JS-functino可以作为参数123456789101112131415161718192021222324252627282930313233343536&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;JS-functino可以作为参数&lt;/TITLE&gt; &lt;style&gt;&lt;/style&gt; &lt;/HEAD&gt; &lt;BODY style="height:1500px;" &gt;&lt;script&gt;//js是一个基于对象的语言//给hello赋值一个匿名函数var hello = function()&#123; alert("HelloWorld");&#125;//js中允许function对象作为参数传递function xx(fun)&#123; alert("接下来给大家展示一下function"); fun();//执行传进来的函数 alert("function展示结束");&#125;//调用xx，把已经存在的hello传进去xx(hello);xx(function()&#123; alert("这次没有调用Hello，这是一个匿名function");&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JS-回调函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;JS-回调函数&lt;/TITLE&gt; &lt;style&gt;&lt;/style&gt; &lt;/HEAD&gt; &lt;BODY style="height:1500px;" &gt;&lt;script&gt;//回调：回去调用，回头调用,//利用回调函数可以实现类似于监听器的功能//这个一个function，用来输出100次HelloWorld//a在开始之前执行//b在第5次执行//c在结束之后执行function hello(a,b,c)&#123; if(a)a(); for(var i=1;i&lt;=10;i++)&#123; console.log("HelloWorld"+i); if(i==5)&#123; if(b)b(); &#125; &#125; if(c)c();&#125;var start = function()&#123; console.log("Start");&#125;;var hot = function()&#123; console.log("中间");&#125;;var end = function()&#123; console.log("Over");&#125;;//当我们调用的时候会传进去3个function，这三个function早就存在了//hello在执行过程中会回来调用他们，这就叫回调hello(start,hot,end);//传3个匿名函数过去，还是匿名函数用着方便hello(function()&#123; console.log("--------1");&#125;,function()&#123; console.log("--------2");&#125;,function()&#123; console.log("--------3");&#125;);//只带一个回调hello(function()&#123; console.log("开始，开始，开始，重要的事说三遍");&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JS-计时器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;JS-计时器&lt;/TITLE&gt; &lt;style&gt;&lt;/style&gt; &lt;/HEAD&gt; &lt;BODY style="height:1500px;" &gt;&lt;input type="button" value="点击" onclick="go()"/&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;form&gt;&lt;input type="button" value="开始计时！" onClick="timedCount()"&gt;&lt;input type="text" id="txt"&gt;&lt;input type="button" value="停止计时！" onClick="stopCount()"&gt;&lt;input type="button" value="归零！" onClick="init()"&gt;&lt;/form&gt;&lt;script&gt;/**js中没有等待功能，计时器可以模拟等待功能计时器是独立的，不会阻塞程序流程的进行*///------------- 可以暂停的计时器 ------------var c=0 //记录时间var t //计时器对象function timedCount()&#123; document.getElementById('txt').value=c c=c+1 t=setTimeout("timedCount()",100);&#125;function stopCount()&#123; clearTimeout(t);&#125;function init()&#123; c=0;&#125;//--------------- 计时器是独立出来的计划任务 ------------function hello(n)&#123; console.log("HelloWorld:"+n);&#125;function go()&#123; for(var i=1;i&lt;=10;i++)&#123; var str = "hello("+i+")"; //计时器是独立的，不会阻塞for的执行 setTimeout(str,1000*i); &#125; console.log("go执行结束");&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Web学习</category>
      </categories>
      <tags>
        <tag>Web学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web学习-1]]></title>
    <url>%2F2019%2F07%2F27%2F12%2F</url>
    <content type="text"><![CDATA[HTMLHTML实例：1234567891011新建一个hello.html文件, 写入如下内容，用浏览器打开：&lt;html&gt; &lt;head&gt; &lt;title&gt;页面的标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;这是我的页面。 &lt;b&gt;这是粗体文本。&lt;/b&gt; &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 例子解释：HTML文件中的第一个标签是。这个标签告诉浏览器这个HTML文件的开始点。文件中最后一个标签是 。这个标签告诉浏览器，这是结束点。位于标签和标签之间的是头信息。头信息不会显示在浏览器窗口中，通常用于设定编码、自动跳转、SEO优化信息等。 是标题，会显示在浏览器的标题栏。 中的文本是页面的显示部分。 和 标签中的文本将以粗体显示。 是标题，会显示在浏览器的标题栏。 中的文本是页面的显示部分。 和 标签中的文本将以粗体显示。 123456&gt; &gt; &lt;title&gt;是标题，会显示在浏览器的标题栏。&gt; &lt;body&gt;中的文本是页面的显示部分。&gt; &lt;b&gt; 和 &lt;/b&gt; 标签中的文本将以粗体显示。&gt; &gt; L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false}); HT2L文档结构1234567891011121314HTML须包含的基本结构标记符：HTML标记：&lt;HTML&gt; &lt;/HTML&gt;头标记： &lt;HEAD&gt; &lt;/HEAD&gt;标题标记： &lt;TITLE&gt; &lt;/TITLE&gt;正文标记： &lt;BODY&gt; &lt;/BODY&gt;三大结构： &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;/BODY&gt; &lt;/HTML&gt; 常用术语 – 元素常用术语 – 属性12345678910&lt;html&gt;&lt;head&gt;&lt;title&gt;背景颜色&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor="yellow" &gt;&lt;h2&gt;请看: 改变了颜色的背景。&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 为HTML元素提供各种附加信息的就是HTML属性，它总是以”属性名=属性值”这种名值对的形式出现，而且属性总是在HTML元素的开始标签中进行定义。 HTML注释 HTML-表单123456789&lt;input type=“text” value=“文本”&gt;&lt;/input&gt;文本框：text密码框：password单选框：radio复选框：checkbox普通按钮：button提交按钮：submit重置按钮：reset HTML-超链接1234&lt;a href=“http://www.baidu.com”&gt;百度一下&lt;/a&gt;锚点：&lt;a name=“dian”&gt;&lt;/a&gt; HTML-图片123451.图像标签&lt;img src=“图片路径”&gt;&lt;/img&gt;2.Body属性&lt;body background=“图片路径" &gt; HTML-路径1234/ 根路径./ 当前目录../ 上层目录../../ 上层目录的上层目录 CSS CSS又称级联样式表，是用来美化页面效果的神器，目前最新版本为CSS3，是能够真正做到网页表现与内容分离的一种样式设计语言。CSS能够对网页中的对象的位置排版进行像素级的精确控制，支持几乎所有的字体字号样式，并能够进行初步交互设计，是目前基于文本展示最优秀的表现设计语言。 ID选择器 id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。 id 选择器以 “#” 来定义，元素id不可重复定义。 12345678910&lt;html&gt;&lt;style&gt;#red &#123;color:red;&#125;#green &#123;color:green;&#125;&lt;/style&gt;&lt;body&gt;&lt;p id="red"&gt;这个段落是红色。&lt;/p&gt;&lt;p id="green"&gt;这个段落是绿色。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; Class选择器 class 选择器可以为标有特定class的元素指定特定的样式。 class选择器以 “.” 来定义，多个元素可共用一个class。 123456789101112&lt;html&gt;&lt;style&gt;.red &#123;color:red;&#125;.green &#123;color:green;&#125;&lt;/style&gt;&lt;body&gt;&lt;p class="red"&gt;这个段落是红色。&lt;/p&gt;&lt;p class="green"&gt;这个段落是绿色。&lt;/p&gt;&lt;p class="red"&gt;这段又是红色，吼吼。&lt;/p&gt;&lt;p class="green"&gt;这段又是绿色，哈哈。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; DIV+CSS全屏固定背景1234567891011&lt;div id="bg"&gt;&lt;/div&gt;&lt;style&gt;#bg&#123;background-image: url(background_1.jpg);background-repeat:no-repeat;background-size:100% 100%;position: fixed;left: 0;right: 0;top: 0;bottom: 0;z-index: -999;&#125;&lt;/style&gt; 实战演习：自定义按钮样式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;自定义按钮样式&lt;/TITLE&gt; &lt;link rel="stylesheet" type="text/css" href="css/McStyle.css" /&gt; &lt;style&gt;.btn&#123; padding:8px; cursor:pointer; font-size:14px; border:1px solid transparent; border-radius:4px;&#125;.btn-default&#123; background-color:#fff; border-color:#aaa;&#125;.btn-default:hover&#123; background-color:#e5e5e5;&#125;.btn-default:active&#123; background-color:#ccc;&#125;.btn-primary&#123; background-color:#337ab7; border-color:#2f6da4; color:#fff;&#125;.btn-primary:hover&#123; background-color:#286090;&#125;.btn-primary:active&#123; background-color:#204d74;&#125;.btn-danger&#123; background-color:#d9534f; border-color:#d43f3a; color:#fff;&#125;.btn-danger:hover&#123; background-color:#c9302c;&#125;.btn-danger:active&#123; background-color:#ae0000;&#125;.btn-success&#123; background-color:#5cb85c; border-color:#4cae4c; color:#fff;&#125;.btn-success:hover&#123; background-color:#449d44;&#125;.btn-success:active&#123; background-color:#007700;&#125;.btn-info&#123; background-color:#5bc0de; border-color:#46b8da; color:#fff;&#125;.btn-info:hover&#123; background-color:#31b0d5;&#125;.btn-info:active&#123; background-color:#1195b5;&#125;&lt;/style&gt; &lt;/HEAD&gt; &lt;BODY style="height:1500px;" &gt; &lt;button &gt;点这里，点这里&lt;/button&gt; &lt;button class="btn btn-default"&gt;我的默认按钮样式&lt;/button&gt; &lt;button class="btn btn-primary"&gt;我的主要按钮样式&lt;/button&gt; &lt;button class="btn btn-danger"&gt;我的危险按钮样式&lt;/button&gt; &lt;button class="btn btn-success"&gt;我的成功按钮样式&lt;/button&gt; &lt;button class="btn btn-info"&gt;我的消息按钮样式&lt;/button&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;button class="btn btn-default" style="width:200px;"&gt;新按钮&lt;/button&gt; &lt;input type="button" class="btn btn-default" value="input也可以使用哦" /&gt; &lt;div class="btn btn-default" style="width:150px;float:left;margin:0 3px ;"&gt;DIV也可以使用哦&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 自定义文本框样式12345678910111213141516171819202122232425262728293031323334353637383940&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;自定义文本框样式&lt;/TITLE&gt; &lt;link rel="stylesheet" type="text/css" href="css/McStyle.css" /&gt; &lt;style&gt;.form-text&#123; padding:8px; font-size:16px; border:1px solid #ccc; border-radius:5px; box-shadow:0 1px 1px rgba(0,0,0,0.2) inset; width:400px; margin:2px;&#125;.form-text:focus&#123; border-color:66afe9; box-shadow:0 2px 2px rgba(0,0,0,0.2) inset,0 0 9px rgba(100,170,235,0.65);&#125;&lt;/style&gt;&lt;!--box-shadow:x位移 y位移 阴影大小 rgba(红，绿，蓝，透明度) inset代表内阴影，不加就是外阴影位移是相对当前元素边界进行位移rgb颜色取值是：0-255--&gt; &lt;/HEAD&gt; &lt;BODY style="height:1500px;" &gt; &lt;input type="text" value="这个是原始的文本框" /&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;input class="form-text" type="text" value="" placeholder="请填写用户名..." /&gt; &lt;br&gt; &lt;input class="form-text" type="password" value="" placeholder="请填写用户名..." /&gt;&lt;/body&gt;&lt;/html&gt; CSS定位1234567891011121314151617181920212223242526272829303132333435&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;我的页面&lt;/TITLE&gt; &lt;style&gt; &lt;/style&gt; &lt;/HEAD&gt; &lt;BODY bgcolor="#eeeeee" style="height:1500px;" &gt; 绝对定位(absolute):脱离文档流，相对于父元素进行绝对定位&lt;br&gt; 相对定位(relative):不脱离文档流，占用原位置，相对于父元素进行绝对定位&lt;br&gt; 固定定位(fixed):相对于浏览器窗口进行定位，不受滚动条移动的影响 &lt;!-- 绝对定位(absolute) --&gt; &lt;div style="position:absolute;width:200px;height:200px;background-color:#FFCCCC;left:100px;top:100px;"&gt; &lt;div style="position:absolute;width:200px;height:200px;background-color:#FFFF99;left:100px;top:100px;"&gt; &lt;/div&gt; &lt;/div&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;!-- 相对定位(relative) --&gt; 共创 &lt;div style="position:relative;width:100px;height:100px;background-color:#996699;left:400px;top:160px;"&gt;&lt;/div&gt; 中国梦 &lt;!-- 固定定位(fixed) --&gt; &lt;div style="position:fixed;width:50px;height:50px;background-color:#33CC33;right:20px;bottom:20px;"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Web学习</category>
      </categories>
      <tags>
        <tag>Web学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC学习-3]]></title>
    <url>%2F2019%2F07%2F26%2F11%2F</url>
    <content type="text"><![CDATA[DAO设计模式[TOC] UserDAO.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package demo.dao;import java.util.List;import demo.model.User;/** * 实体操作接口 * @author */public interface UserDAO &#123; /** * 保存用户 * @param u * @return 本次成功修改条数 */ int save(User u); /** * 修改用户信息 * @param u * @return */ int update(User u); /** * 通过id删除用户 * @param id * @return */ int delete(int id); /** * 通过用户id查人 * @param id * @return */ User findById(int id); /** * 查询所有用户 * @return */ List&lt;User&gt; findAll(); /** * 通过用户名和密码查人 * @param name * @param pass * @return */ User find(String name,String pass);&#125; UserDaoImpl.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152package demo.dao.impl;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.ArrayList;import java.util.List;import demo.dao.UserDAO;import demo.model.User;import demo.util.JDBCUtil;/** * 数据持久化的MySQL实现 * * * * */public class UserDaoImpl implements UserDAO &#123; @Override public int save(User u) &#123; Connection conn = JDBCUtil.getConnection(); PreparedStatement pst = null; String sql = "insert into usr values(0,?,?)"; try &#123; pst = conn.prepareStatement(sql); pst.setString(1, u.getUname()); pst.setString(2, u.getUpass()); return pst.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; JDBCUtil.close(conn, pst); &#125; return 0; &#125; @Override public int update(User usr) &#123; Connection conn = JDBCUtil.getConnection(); PreparedStatement pst = null; String sql = "update usr set usrname=?,usrpass=? where id=?"; try &#123; pst = conn.prepareStatement(sql); pst.setString(1, usr.getUname()); pst.setString(2, usr.getUpass()); pst.setInt(3, usr.getId()); return pst.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; JDBCUtil.close(conn, pst); &#125; return 0; &#125; @Override public int delete(int id) &#123; Connection conn = JDBCUtil.getConnection(); PreparedStatement pst = null; String sql = "delete from usr where id=?"; try &#123; pst = conn.prepareStatement(sql); pst.setInt(1, id); return pst.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; JDBCUtil.close(conn, pst); &#125; return 0; &#125; @Override public User findById(int id) &#123; Connection conn = JDBCUtil.getConnection(); PreparedStatement pst = null; ResultSet rs = null; String sql = "select * from usr where id=?"; try &#123; pst = conn.prepareStatement(sql); pst.setInt(1, id); rs = pst.executeQuery(); while(rs.next())&#123; User usr = new User(); usr.setId(rs.getInt("id")); usr.setUname(rs.getString("usrname")); usr.setUpass(rs.getString("usrpass")); return usr; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; JDBCUtil.close(conn, pst, rs); &#125; return null; &#125; @Override public List&lt;User&gt; findAll() &#123; List&lt;User&gt; userList = new ArrayList&lt;User&gt;(); Connection conn = JDBCUtil.getConnection(); PreparedStatement pst = null; ResultSet rs = null; String sql = "select * from usr"; try &#123; pst = conn.prepareStatement(sql); rs = pst.executeQuery(); while(rs.next())&#123; User usr = new User(); usr.setId(rs.getInt("id")); usr.setUname(rs.getString("usrname")); usr.setUpass(rs.getString("usrpass")); userList.add(usr); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; JDBCUtil.close(conn, pst, rs); &#125; return userList; &#125; @Override public User find(String name, String pass) &#123; Connection conn = JDBCUtil.getConnection(); PreparedStatement pst = null; ResultSet rs = null; String sql = "select * from usr where usrname=? and usrpass=?"; try &#123; pst = conn.prepareStatement(sql); pst.setString(1, name); pst.setString(2, pass); rs = pst.executeQuery(); while(rs.next())&#123; User usr = new User(); usr.setId(rs.getInt("id")); usr.setUname(rs.getString("usrname")); usr.setUpass(rs.getString("usrpass")); return usr; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; JDBCUtil.close(conn, pst, rs); &#125; return null; &#125;&#125; User.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546package demo.model;/** * 实体模型 * */public class User &#123; private int id; private String uname; private String upass; public User() &#123; // TODO Auto-generated constructor stub &#125; public User(String uname, String upass) &#123; this.uname = uname; this.upass = upass; &#125; public User(int id, String uname, String upass) &#123; this.id = id; this.uname = uname; this.upass = upass; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUname() &#123; return uname; &#125; public void setUname(String uname) &#123; this.uname = uname; &#125; public String getUpass() &#123; return upass; &#125; public void setUpass(String upass) &#123; this.upass = upass; &#125; &#125; UserDAOTest.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package demo.test;import static org.junit.Assert.*;import java.util.List;import org.junit.Before;import org.junit.Test;import demo.dao.UserDAO;import demo.dao.impl.UserDaoImpl;import demo.model.User;import demo.util.DaoFactory;/** * 单元测试DEMO * * JUnit 4 开始使用 Java 5 中的注解（annotation），常用的几个 annotation 介绍： * @BeforeClass：针对所有测试，只执行一次，且必须为static void * @Before：初始化方法 * @Test：测试方法，在这里可以测试期望异常和超时时间 * @After：释放资源 * @AfterClass：针对所有测试，只执行一次，且必须为static void * @Ignore：忽略的测试方法 * * 一个单元测试用例执行顺序为： * @BeforeClass –&gt; @Before –&gt; @Test –&gt; @After –&gt; @AfterClass * 每一个测试方法的调用顺序为： * @Before –&gt; @Test –&gt; @After * * @author 夏增明 create data:2015-11-13 * */public class UserDAOTest &#123; UserDAO dao = DaoFactory.getUserDao(); @Before public void setUp() throws Exception &#123; System.out.println("-------------"); &#125; //@Test public void testSave() &#123; User usr1 = new User("吕布", "123456"); User usr2 = new User("吕小布", "564654"); User usr3 = new User("吕大布", "987987"); dao.save(usr1); dao.save(usr2); dao.save(usr3); &#125; //@Test public void testUpdate() &#123; User usr = new User(8, "小吕布", "111111"); dao.update(usr); &#125; //@Test public void testDelete() &#123; dao.delete(9); dao.delete(10); dao.delete(11); &#125; //@Test public void testFindById() &#123; User usr = dao.findById(8); if(usr==null)&#123; fail("BUG:8号数据没有查到"); &#125;else&#123; System.out.println(usr.getUname()); &#125; &#125; //@Test public void testFindAll() &#123; List&lt;User&gt; list = dao.findAll(); if(list.size()!=7)&#123; fail("记录个数不对"); &#125;else&#123; for(User u : list)&#123; System.out.println(u.getUname()); &#125; &#125; &#125; @Test public void testFind() &#123; //测试用例1，正确情况 User usr = dao.find("admin", "123"); if(usr==null || usr.getId()!=4)&#123; fail("查到的数据不对"); &#125;else&#123; System.out.println(usr.getId()+","+usr.getUname()+","+usr.getUpass()); &#125; //测试用例2，故意填错 User usr1 = dao.find("admin", "123456"); if(usr1==null || usr1.getId()!=4)&#123; System.out.println("功能OK"); &#125;else&#123; fail("密码不对都能登录，重大BUG"); &#125; &#125;&#125; DaoFactory.java1234567891011121314151617181920212223package demo.util;import demo.dao.BookDao;import demo.dao.UserDAO;import demo.dao.impl.UserDaoImpl;/** * 用来创建Dao对象的工厂，可以实现统一 * @author * */public class DaoFactory &#123; public static UserDAO getUserDao()&#123; return new UserDaoImpl(); &#125; public static BookDao getBookDao()&#123; return null; &#125; //以此类推&#125; JDBCUtil.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package demo.util;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;/** * JDBC工具类：主要功能包括【获取连接】，【释放jdbc资源】 * * */public class JDBCUtil &#123; //数据库连接配置 private static String url = "jdbc:mysql://192.168.10.235:3306/wukong_db"; private static String user = "wukong"; private static String pass = "123"; static&#123; //第一次运行的时候加载驱动 try &#123; new com.mysql.jdbc.Driver(); &#125; catch (SQLException e) &#123; System.out.println("MySQL驱动加载异常！"); e.printStackTrace(); &#125; &#125; /** * 工厂模式获取新连接 * @return */ public static Connection getConnection()&#123; try &#123; Connection conn = DriverManager.getConnection(url, user, pass); return conn; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 关闭物理连接 * @param conn */ public static void close(Connection conn)&#123; close(conn, null, null); &#125; /** * 关闭物理连接 * @param conn */ public static void close(Connection conn,Statement st)&#123; close(conn, st, null); &#125; /** * 关闭物理连接 * @param conn */ public static void close(Connection conn,Statement st,ResultSet rs)&#123; try &#123; if(rs!=null)rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(st!=null)st.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn!=null)conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; JDBC连接池JDBC连接池又叫数据源 连接池说明 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池 两种开源连接池JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, JBoss, Tomcat)提供实现，也有一些开源组织提供实现：DBCP 连接池C3P0 连接池 (常用)DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池 C3p0使用 使用c3p0需要导入c3p0的jar包 1234567891011121314151617//首先需要创建连接池对象ComboPooledDataSource ds = new ComboPooledDataSource();try&#123; //设置驱动和url ds.setDriverClass("oracle.jdbc.driver.OracleDriver"); ds.setJdbcUrl("jdbc:oracle:thin:@127.0.0.1:1521:orcl"); //设置用户名和密码 ds.setUser("hehe"); ds.setPassword("abc"); ds.setMaxPoolSize(40);//最大连接数 ds.setMinPoolSize(40);//最小连接数 ds.setInitialPoolSize(10);//初始连接数 Connection conn = ds.getConnection(); System.out.println("成功从c3p0获取连接");&#125;catch(Exception e)&#123; e.printStackTrace();&#125;]]></content>
      <categories>
        <category>JDBC学习</category>
      </categories>
      <tags>
        <tag>JDBC学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC学习-2]]></title>
    <url>%2F2019%2F07%2F26%2F10%2F</url>
    <content type="text"><![CDATA[JDBC操作数据库1. JDBC API核心类：Driver DriverManager Connection Statemen ResultSet 2.预编译PreparedStarement的应用及其作用 JDBC API核心类 1.Driver:代表驱动程序 DirverManager类：是JDBC的管理层，作用于用户和驱动之间。负责注册和加载JDBC驱动 Connection接口：conn代表与数据库的连接。当用户与数据库交互的时候，首先必须建立一个数据库链接，只有在获得链接之后，才能进行进一步的操作，是用户与数据库之间的桥梁。 Statement对象 ：st用于执行静态 SQL 语句并返回结果。Statement可以通过Connection对象的createStatement()方法创建。Statement对象只能执行静态sql语句。不能可以执行动态的sql（sql串中有参数），执行动态sql使用PreparedStatement对象，用法和Statement类似。 ResultSet对象：rsResultSet对象是结果集对象。当程序执行一条用于查询功能的sql语句（select）后，JDBC会把数据库的查询结果封装成一个ResultSet对象返回给程序。ResultSet 对象具有指向其当前数据行的指针，用户可以移动该指针读取ResultSet中的不同记录。另外ResultSet对象还封装了一些关于结果集表的列名、数据类型等信息，这些信息一般可以通过ResultSetMetaData对象来读取。 JDBC事务处理 让多条SQL语句作为一个事务执行，需要取消自动提交：conn. setAutoCommit(false); 在所有SQL语句都执行成功后，使用commit();提交事务在出现异常时，调用 rollback(); 方法回滚事务 12345678910111213//向数据库中添加10条记录，如果有异常，全部撤销Statement st = conn.createStatement();try&#123; onn.setAutoCommit(false);//取消自动提交 for(int i = 0;i&lt;10;i++)&#123; st.executeUpdate("insert into student values('小明',20)"); &#125; conn.commit();//提交事务&#125;catch(Exception e)&#123; conn.rollback();//如果没有成功，则事务回滚&#125;finally&#123; conn.setAutoCommit(true);//恢复事务自动提交&#125; 资源释放 数据库连接是有数量限制的，用完的连接应及时关闭。 ResultSet 、Statement 和Connetction是依次依赖的。 要按先 ResultSet ，再Statement，最后Connetction的顺序关闭资源。 因ResultSet和Statement在连接的情况下才能使用，所以在连使用束 后可能还有其他的statement还在连接，所以不能先关闭Connection。 调用close（）方法: rs.close(); sta.close(); conn.close(); PreparedStatement PreparedStatement是预编译语句，继承自Statement，但比Statement功能强大的多。它可以在SQL语句中用问号(?)来代替变量，接下来可以提供多组值，最后执行： 123456conn.setAutoCommit(false); //设置不自动commit//用问号表示名字和年龄PreparedStatement pst = conn.prepareStatement(“insert into student values(?, ?)”); pst.setString(1,”李雷”); pst.setInt(2,24); pst.addBatch();//一条记录pst.setString(1,”李元芳”); pst.setInt(2,33); pst.addBatch();//又一条记录pst.executeBatch();//批量执行 编写JDBC工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package util;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;/** * JDBC工具类：主要功能包括【获取连接】，【释放jdbc资源】 * @author * */public class JDBCUtil &#123; //数据库连接配置 private static String url = "jdbc:mysql://192.168.0.107:3306/wukong_db"; private static String user = "wukong"; private static String pass = "123"; static&#123; //第一次运行的时候加载驱动 try &#123; new com.mysql.jdbc.Driver(); &#125; catch (SQLException e) &#123; System.out.println("MySQL驱动加载异常！"); e.printStackTrace(); &#125; &#125; /** * 工厂模式获取新连接 * @return */ public static Connection getConnection()&#123; try &#123; Connection conn = DriverManager.getConnection(url, user, pass); return conn; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 关闭物理连接 * @param conn */ public static void close(Connection conn)&#123; close(conn, null, null); &#125; /** * 关闭物理连接 * @param conn */ public static void close(Connection conn,Statement st)&#123; close(conn, st, null); &#125; /** * 关闭物理连接 * @param conn */ public static void close(Connection conn,Statement st,ResultSet rs)&#123; try &#123; if(rs!=null)rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(st!=null)st.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; if(conn!=null)conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JDBC学习</category>
      </categories>
      <tags>
        <tag>JDBC学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC学习-1]]></title>
    <url>%2F2019%2F07%2F25%2F9%2F</url>
    <content type="text"><![CDATA[MySQL管理员的基本素养 MySQL中默认用户：root@localhost 初学者对于默认用户不要做任何修改 作为root，千万不要取消自己的服务器权限 在MySQL中root@localhost和root@%不是同一个用户 普通权限/服务器权限：服务器权限通常都是给各种管理者使用的 root主要功能是创建用户和维护权限开发期间为自己创建一个普通用户作为管理员，要低调，不要使用root做开发 JDBC 1 JDBC基本概念 2 JDBC的四种驱动类型 3 JDBC开发接口 4 区分不同数据库的方式—URL 5 访问数据库 6 注册驱动的几种方法 JDBC基本概念 JDBC（Java Data Base Connectivity,java数据库连接），JDBC提供了一个标准的API，使开发人员能够使用 Java操作数据库。由一组用Java语言编写的类和接口组成用于执行SQL语句可以为多种关系数据库提供统一访问 JDBC的四种驱动类型1.JDBC-ODBC桥 2.本地API驱动 3.网络协议驱动 4.本地协议驱动 本地协议驱动（纯Java）JDBC开发接口1.Java.sql.Driver 接口是所有JDBC驱动程序需要实现的接口2.DriverManager 类：驱动程序管理员3.Connection 接口：代表数据库连接4.Statement 、PreparedStatement、CallableStatement 接口：数据库操作对象5.ResultSet 接口：代表结果集6.DatabaseMetadata、ResultSetMetadata接口：代表元数据7.Types 类：代表JDBC类型 不同数据库的URLOracle驱动JAR包：ojdbc14.jar驱动程序类名: oracle.jdbc.driver.OracleDriverJDBC URL:jdbc:oracle:thin:@//:port&gt;/ServiceNamejdbc:oracle:thin:@:: MySQL驱动JAR包：mysql-connector-java-x.x.xx-bin.jar驱动程序类名: com.mysql.jdbc.DriverJDBC URL: jdbc:mysql://:/默认端口3306，如果服务器使用默认端口则port可以省略MySQL Connector/J Driver 允许在URL中添加额外的连接属性jdbc:mysql://:/?property1=value1&amp;property2=value2 Java访问Oracle数据库123456789//注册JDBC驱动Class.forName("oracle.jdbc.driver.OracleDriver"); //定义连接字符串String url="jdbc:oracle:thin:@localhost:1521:orcl"; //orcl为数据库的SID String user=“hehe"; String password=“abc"; //使用驱动管理器建立与数据库的连接Connection conn= DriverManager.getConnection(url,user,password); 123456789101112131415161718192021222324252627package hello;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class Test &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; // JDBC开发第一步导入驱动包jar String url = "jdbc:oracle:thin:@//192.168.0.105:1521/orcl"; String name = "liuyanhao"; String password = "abc123"; //注册jdbc驱动 Class.forName("oracle.jdbc.driver.OracleDriver"); //使用驱动管理器获得一条连接 Connection conn = DriverManager.getConnection(url, name, password); if(conn!=null) &#123; System.out.println("连接数据库成功"); &#125; conn.close(); &#125;&#125; 注册驱动的方式123456781.使用JVM查找类名并加载Class.forName(" oracle.jdbc.driver.OracleDriver ");2.通过系统属性设置System.setProperty("jdbc.drivers","oracle.jdbc.driver.OracleDriver");3.注册相应的JDBC驱动，比较直观new oracle.jdbc.driver.OracleDriver(); 通过Java操作数据库1.导入驱动jar包2.注册JDBC驱动类3.建立数据库连接Connection4.通过连接创建数据库操作对象Statement5.创建结果集ResultSet6.关闭各种jdbc相关对象关闭顺序：rs / st / conn 执行SQL123456789Statement st = conn.createStatement();Statement对象可以执行SQL语句：st.executeQuery(sql)执行select语句返回结果集st.executeUpdate(sql)可以执行insert或update语句返回受影响的行数可以执行DDL，返回行数为0 123456789101112131415161718192021222324252627282930313233343536373839404142434445package hello;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class MyTest &#123; public static void main(String[] args) throws ClassNotFoundException &#123; // 导入jar包 String url = "jdbc:mysql://192.168.0.105:3306/lyh"; String user = "LYH"; String password = "123456"; String sql = "create table student(id int,name varchar(255),age int);"; try &#123; //注册JDBC驱动 Class.forName("com.mysql.jdbc.Driver"); //使用驱动管理器建立与数据库的连接 Connection coon = DriverManager.getConnection(url, user, password); System.out.println("连接数据库成功"); //在连接成功后，st可以执行SQL Statement st = coon.createStatement(); //执行sql语句，创建student表 st.execute(sql); //增删改查用Update，返回受影响的行数 int i = st.executeUpdate("insert into student values(1,'大明',20);"); System.out.println(i); //ResultSet是一个结果集，默认的游标为0，结果集就相当于查询返回的表 ResultSet rs = st.executeQuery("select * from student"); while( rs.next())//向下移动游标，从而指向第一行,返回boolean值 &#123; System.out.println(rs.getString("id")); System.out.println(rs.getString("name")); System.out.println(rs.getString("age")); &#125; &#125;catch(SQLException x) &#123; x.printStackTrace(); &#125;&#125;&#125;]]></content>
      <categories>
        <category>JDBC学习</category>
      </categories>
      <tags>
        <tag>JDBC学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习-4]]></title>
    <url>%2F2019%2F07%2F24%2F8%2F</url>
    <content type="text"><![CDATA[存储过程1234567891011121314151617181920存储过程create or replaceprocedure pro_hello(--参数列表 A IN NUMBER, B IN NUMBER, C OUT NUMBER)IS 注意：如果这里不需要变量，要用 AS --定义变量x integer := 0;y integer := 2;BEGIN x := A*2; y := B; SELECT (x+y) INTO C FROM DUAL;END pro_hello; 注意分号的使用 函数1234567891011121314151617181920create or replaceFUNCTION FUN_SUM(--参数列表 A IN NUMBER, B IN NUMBER, C OUT NUMBER)RETURN NUMBER IS 注意：如果这里不需要变量，要用 AS --定义变量x integer := 0;y integer := 2;BEGIN x := A*2; y := B; SELECT (x+y) INTO C FROM DUAL; RETURN C;END FUN_SUM; 函数可以用sql语句调用： select FUN_SUM(10,20) from dual;]]></content>
      <categories>
        <category>Oracle学习</category>
      </categories>
      <tags>
        <tag>Oracle学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle学习-3]]></title>
    <url>%2F2019%2F07%2F23%2F7%2F</url>
    <content type="text"><![CDATA[Oracle常用函数字符函数数字函数日期函数转换函数系统函数 字符函数lower(char)：将字符串转化为小写的格式。upper(char)：将字符串转化为大写的格式。 length(char)：返回字符串的长度。 substr(char, start, len)：截取字符串的子串，n代表取n个字符的意思，不是代表取到第n个 replace(char1, search_string, replace_string) instr(C1,C2,I,J) –&gt;判断某字符或字符串是否存在，存在返回出现的位置的索引，否则返回小于1;在一个字符串中搜索指定的字符,返回发现指定的字符的位置; C1 被搜索的字符串 C2 希望搜索的字符串 I 搜索的开始位置,默认为1 J 出现的位置,默认为1 问题：将所有员工的名字按小写的方式显示 SQL&gt; select lower(ename) from emp; 问题：将所有员工的名字按大写的方式显示。 SQL&gt; select upper(ename) from emp; 问题：显示正好为5个字符的员工的姓名。 SQL&gt; select * from emp where length(ename)=5; 问题：显示所有员工姓名的前三个字符。 SQL&gt; select substr(ename, 1, 3) from emp; 问题：以首字母大写,后面小写的方式显示所有员工的姓名。 SQL&gt; select upper(substr(ename,1,1)) || lower(substr(ename,2,length(ename)-1)) from emp; 问题：以首字母小写,后面大写的方式显示所有员工的姓名。 SQL&gt; select lower(substr(ename,1,1)) || upper(substr(ename,2,length(ename)-1)) from emp; 问题：显示所有员工的姓名，用“我是老虎”替换所有“A” SQL&gt; select replace(ename,’A’, ‘我是老虎’) from emp; 问题：instr(char1,char2,[,n[,m]])用法 SQL&gt; select instr(‘azhangsanbcd’, ‘zhangsan’) from dual; –返回2 SQL&gt; select instr(‘oracle traning’, ‘ra’, 1, 1) instring from dual; –返回2 SQL&gt; select instr(‘oracle traning’, ‘ra’, 1, 2) instring from dual; –返回9 SQL&gt; select instr(‘oracle traning’, ‘ra’, 1, 3) instring from dual; –返回0，根据条件，由于ra只出现二次，第四个参数3，就是说第3次出现ra的位置，显然第3次是没有再出现了，所以结果返回0。注意空格也算一个字符 SQL&gt; select instr(‘abc’,’d’) from dual; –返回0 数字四舍五入函数数学函数的输入参数和返回值的数据类型都是数字类型的。数学函数包括cos，cosh，exp，ln, log，sin，sinh，sqrt，tan，tanh，acos，asin，atan，round等 我们讲最常用的： round(n,[m]) 该函数用于执行四舍五入， 如果省掉m，则四舍五入到整数。 如果m是正数，则四舍五入到小数点的m位后。 如果m是负数，则四舍五入到小数点的m位前。 Eg:SELECT round(23.75123) FROM dual; –返回24 SELECT round(23.75123, -1) FROM dual; –返回20 SELECT round(27.75123, -1) FROM dual; –返回30 SELECT round(23.75123, -3) FROM dual; –返回0 SELECT round(23.75123, 1) FROM dual; –返回23.8 SELECT round(23.75123, 2) FROM dual; –返回23.75 SELECT round(23.75123, 3) FROM dual; –返回23.751 数字截取函数trunc(n,[m]) 该函数用于截取数字。 如果省掉m，就截去小数部分， 如果m是正数就截取到小数点的m位后， 如果m是负数，则截取到小数点的前m位。 Eg：SELECT trunc(23.75123) FROM dual; –返回23 SELECT trunc(23.75123, -1) FROM dual; –返回20 SELECT trunc(27.75123, -1) FROM dual; –返回20 SELECT trunc(23.75123, -3) FROM dual; –返回0 SELECT trunc(23.75123, 1) FROM dual; –返回23.7 SELECT trunc(23.75123, 2) FROM dual; –返回23.75 SELECT trunc(23.75123, 3) FROM dual; –返回23.751 数字函数1234567891011mod(m,n)取余函数(取模)eg、select mod(10,2) from dual; --返回0SELECT MOD(10,3) FROM dual; --返回1floor(n) 返回小于或是等于n的最大整数ceil(n) 返回大于或是等于n的最小整数eg、SELECT ceil(24.56) from dual; --返回25 SELECT floor(24.56) from dual; --返回24abs(n) 返回数字n的绝对值对数字的处理，在财务系统或银行系统中用的最多，不同的处理方法，对财务报表有不同的结果 日期函数1234567891011121314151617181920日期函数用于处理date类型的数据。默认情况下日期格式是dd-mon-yy 即“06-8 月-14” (1)sysdate 返回系统时间eg:SQL&gt; select sysdate from dual;(2)oracle add_months函数oracle add_months(time,months)可以得到某一时间之前或之后n个月的时间eg：select add_months(sysdate,-6) from dual;--该查询的结果是当前时间半年前的时间select add_months(sysdate,6) from dual; --该查询的结果是当前时间半年后的时间 (3) last_day(d) ：返回指定日期所在月份的最后一天 问题：查找已经入职8个月多的员工 SQL&gt; select * from emp where sysdate&gt;=add_months(hiredate,8); 问题：显示满10年服务年限的员工的姓名和受雇日期。 SQL&gt; select ename, hiredate from emp where sysdate&gt;=add_months(hiredate,12*10); 问题：对于每个员工，显示其加入公司的天数。 SQL&gt; select floor(sysdate-hiredate) "入职天数",ename from emp; 或者 SQL&gt; select trunc(sysdate-hiredate) "入职天数",ename from emp; 问题：找出各月倒数第3天受雇的所有员工。 SQL&gt; select hiredate,ename from emp where last_day(hiredate)-2=hiredate; 转换函数 123456789&gt; 转换函数用于将数据类型从一种转为另外一种。在某些情况下，oracle server允许值的数据类型和实际的不一样，这时oracle server会隐含的转化数据类型&gt; 比如：&gt; create table t1(id number);&gt; insert into t1 values('10');--这样oracle会自动的将'10' --&gt;10&gt; create table t2 (id varchar2(10));&gt; insert into t2 values(1); --这样oracle就会自动的将1 --&gt;'1'；&gt; 我们要说的是尽管oracle可以进行隐含的数据类型的转换，但是它并不适应所有的情况，为了提高程序的可靠性，我们应该使用转换函数进行转换。&gt; &gt; 12345678910111213141516171819to_char()函数你可以使用select ename, hiredate, sal from emp where deptno = 10;显示信息，可是，在某些情况下，这个并不能满足你的需求。问题：日期是否可以显示 时/分/秒SQL&gt; select ename, to_char(hiredate, 'yyyy-mm-dd hh24:mi:ss') from emp;问题：薪水是否可以显示指定的货币符号SQL&gt;yy：两位数字的年份 2004--&gt;04 yyyy：四位数字的年份 2004年mm：两位数字的月份 8 月--&gt;08 dd：两位数字的天 30 号--&gt;30hh24： 8点--&gt;20 hh12：8点--&gt;08mi、ss--&gt;显示分钟\秒 9：显示数字，并忽略前面00：显示数字，位数不足则用0补齐 .：在指定位置显示小数点,：在指定位置显示逗号 $：在数字前加美元L：在数字前面加本地货币符号 C：在数字前面加国际货币符号 G：在指定位置显示组分隔符、 D：在指定位置显示小数点符号(.)问题：显示薪水的时候，把本地货币单位加在前面SQL&gt; select ename, to_char(hiredate, ‘yyyy-mm-dd hh24:mi:ss’), to_char(sal,‘￥99999.99') from emp;问题：显示1980年入职的所有员工SQL&gt; select * from emp where to_char(hiredate, 'yyyy')=1980;问题：显示所有12月份入职的员工SQL&gt; select * from emp where to_char(hiredate, 'mm')=12; 12345678910111213141516171819202122to_date()函数函数to_date用于将字符串转换成date类型的数据。 问题：能否按照中国人习惯的方式年—月—日添加日期。eg、SELECT to_date('2012-02-18 09:25:30','yyyy-mm-dd hh24:mi:ss') FROM dual;Year: yy two digits 两位年 显示值:07yyy three digits 三位年 显示值:007yyyy four digits 四位年 显示值:2007Month: mm number 两位月 显示值:11mon abbreviated 字符集表示 显示值:11月,若是英文版,显示nov month spelled out 字符集表示 显示值:11月,若是英文版,显示november Day: dd number 当月第几天 显示值:02ddd number 当年第几天 显示值:02dy abbreviated 当周第几天简写 显示值:星期五,若是英文版,显示friday spelled out 当周第几天全写 显示值:星期五,若是英文版,显示friday Hour: hh two digits 12小时进制 显示值:01hh24 two digits 24小时进制 显示值:13 Minute: mi two digits 60进制 显示值:45Second: ss two digits 60进制 显示值:25其它: Q digit 季度 显示值:4WW digit 当年第几周 显示值:44W digit 当月第几周 显示值:124小时格式下时间范围为： 0:00:00 - 23:59:59.... s12小时格式下时间范围为： 1:00:00 - 12:59:59 .... sys_context()系统函数1234567891011121314主要参数：1)terminal：当前会话客户所对应的终端的标示符，如计算机名2)language: 语言3)db_name： 当前数据库名称4)nls_date_format： 当前会话客户所对应的日期格式5)session_user： 当前会话客户所对应的数据库用户名6)current_schema： 当前会话客户所对应的默认方案名7)host： 返回数据库所在主机的名称通过sys_context函数，可以查询一些重要信息，比如你正在使用哪个数据库：select sys_context('USERENV','db_name') from dual;注意：USERENV是固定的，不能改的，db_name可以换成其它,eg、select sys_context('USERENV','language') from dualselect sys_context('USERENV',‘host') from dual;]]></content>
      <categories>
        <category>Oracle学习</category>
      </categories>
      <tags>
        <tag>Oracle学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle数据库-1]]></title>
    <url>%2F2019%2F07%2F22%2F6%2F</url>
    <content type="text"><![CDATA[http://charles-pc:1158/em –企业管理控制台http://charles-pc:5560/isqlplus –网页命令行工具http://charles-pc:5560/isqlplus/dba –网页命令行工具（DBA专用） 系统服务： OracleDBConsoleorcl：企业管理控制台OracleOraDb10g_home1iSQL*Plus：网页命令行OracleOraDb11g_home1TNSListener：远程监听OracleServiceORCL：数据库实例 以上4个服务可以设置为手动启动，以免影响开机速度，==前两个都是辅助，后两个必须启动== SQL：操作数据库用户登录：1.网页iSQLplus2.SQLPlus（白框）3.cmd sqlplus /nolog (黑框) SYS:超级管理员SYSTEM:普通管理员 使用数据库时应该使用普通用户通常管理员账号都是用来做管理 命令行（黑框）：conn 用户名/密码 ; 创建用户张三，密码为abccreate user zhangsan identified by abc; 授权“创建会话”给张三grant create session to zhangsan; create session是一个权限，用于登录 权限体系：用户 - 角色 - 权限 用户：用户名密码组合，用于识别身份角色：一个职位，可以拥有很多权限权限：功能，具体能做的事情 DEMO：create role java; –创建角色名为javagrant connect,resource to java; –为java角色授权grant java to zhangsan; –把java角色授权给张三revoke java from zhangsan; –撤销授权 — 超级管理员登录 —方式1：sqlplus / as sysdba 方式2：sqlplus /nologconn / as sysdba 方式3：sqlplussys as sysdbamima 修改用户密码：alter user 用户名 identified by 新密码; 锁定用户：alter user 用户名 account lock; 用户解锁：alter user 用户名 account unlock; 删除用户：drop user 用户名; Oracle卸载 直接注册表清除，步骤如下： 1、 开始－&gt;设置－&gt;控制面板－&gt;管理工具－&gt;服务 停止所有Oracle服务。 2、 开始－&gt;程序－&gt;Oracle - OraHome81－&gt;Oracle Installation Products－&gt; Universal Installer 卸装所有Oracle产品，但Universal Installer本身不能被删除 5、 运行regedit，选择HKEY_LOCAL_MACHINE\SOFTWARE\ORACLE，按del键删除这个入口。 6、 运行regedit，选择HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services，滚动 这个列表，删除所有Oracle入口。 7、 运行refedit， HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application， 删除所有Oracle入口。 8、 开始－&gt;设置－&gt;控制面板－&gt;系统－&gt;高级－&gt;环境变量 删除环境变量CLASSPATH和PATH中有关Oracle的设定 9、 从桌面上、STARTUP（启动）组、程序菜单中，删除所有有关Oracle的组和图标 10、 删除\Program Files\Oracle目录 11、 重新启动计算机，重起后才能完全删除Oracle所在目录 12、 删除与Oracle有关的文件，选择Oracle所在的缺省目录C:\Oracle，删除这个入 口目录及所有子目录，并从Windows 2000目录（一般为C:\WINNT）下删除以下文 件ORACLE.INI、oradim73.INI、oradim80.INI、oraodbc.ini等等。 13、 WIN.INI文件中若有[ORACLE]的标记段，删除该段 14、 如有必要，删除所有Oracle相关的ODBC的DSN 15、 到事件查看器中，删除Oracle相关的日志]]></content>
      <categories>
        <category>Oracle学习</category>
      </categories>
      <tags>
        <tag>Oracle学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle数据库-2]]></title>
    <url>%2F2019%2F07%2F22%2F5%2F</url>
    <content type="text"><![CDATA[Oracle数据库介绍Oracle数据库中常用的数据类型SQL中常用的命令分类及其使用 Oracle数据库 ORACLE 是以高级结构化查询语言(SQL)为基础的大型关系数据库，通俗地 讲它是用方便逻辑管理的语言去操纵大量有规律数据的集合。是目前最流行的客户端/服务器(CLIENT/SERVER)体系结构的数据库之一。 Oracle数据库中常用的数据类型 分类 数据类型 说明 文本、二进制类型 CHAR(size) char(20) 定长 最大2000字符 文本、二进制类型 VARCHAR(size) varchar(20) ==Varchar2(size)== 变长 最大4000字符 文本、二进制类型 nchar(n) Unicode数据类型 ,定长 最大2000字符 文本、二进制类型 nvarchar2(n) Unicode数据类型 ,变长 最大4000字符 文本、二进制类型 clob(character large object) 字符型大对象 ,最大8tb 文本、二进制类型 blob(binary large object) 二进制数据 可以存放图片/声音 8tb 数值类型 number(p,s) p为整数位,s为小数位.范围： 1 &lt;= p &lt;=38, -84 &lt;= s &lt;= 127 保存数据范围：-1.0e-130 &lt;= number value &lt; 1.0e+126 保存在机器内部的范围： 1 ~ 22 bytes 时间日期 date TIMESTAMP(n) 包含年月日,时分秒。默认格式：DD-MON-YYYY。从公元前4712年1月1日到公元4712年12月31日的所有合法日期 n的取值为0~9.表示指定TIMESTAMP中秒的小数位数。N为可选。如果n为0，timestamp与date等价[不推荐] SQL中常用的命令分类及其使用创建表1234567CREATE TABLE table_name( field1 datatype, field2 datatype, field3 datatype)field：指定列名 datatype：指定列类型 修改表使用 ALTER TABLE 语句添加, 修改, 或删除列的语法. 12345678910ALTER TABLE tablenameADD (columnname datatype);ALTER TABLE tableMODIFY (columnname datatype);ALTER TABLE tableDROP column column;修改表的名称：rename 表名 to 新表名 表中数据的管理 Insert语句 (增加数据) Update语句 (更新数据) Delete语句 (删除数据) Select语句 (查找数据) 增加数据- Insert12INSERT INTO table [(column [, column...])]VALUES (value [, value...]); 插入的数据应与字段的数据类型相同。 数据的大小应在列的规定范围内，例如：不能将一个长度为80的字符串加入到长度为40的列中。 在values中列出的数据位置必须与被加入的列的排列位置相对应。字符和日期型数据应包含在==单引号==中。 插入空值，不指定或insert into table value(null) 例如： 新建学生：Insert into student(id,name,salary,birthday)values (1001,’盖伦’,’6500’,null); 基本查询1SELECT [DISTINCT] *|&#123;column1, column2. column3..&#125;FROM Select 指定查询哪些列的数据。 column指定列名，*号代表查询所有列。 From指定查询哪张表。 DISTINCT可选，指显示结果时，是否剔除重复数据 修改数据- Update123UPDATE tbl_name SET col_name1=expr1 [, col_name2=expr2 ...] [WHERE where_definition] UPDATE语法可以用新值更新原有表行中的各列。 SET子句指示要修改哪些列和要给予哪些值。 WHERE子句指定应更新哪些行。如没有WHERE子句，则更新所有的行 删除数据1234567delete from 表名; 删除所有记录,表结构还在,写日志,可以恢复的,速度慢delete from student where xh='A001'; 删除一条记录drop table 表名; 删除表的结构和数据truncate table 表名; //不常用删除表中的所有记录,表结构还在,不写日志,无法找回删除的记录,速度快 SQL中常用的命令分类及其使用DDL （Data Definition Language ）数据库定义语言 :statements are used to define the database structure or schema，DDL不需要commit. CREATE ：创建 ALTER ：修改 DROP ：删除 TRUNCATE ：截断 COMMENT ：注释 RENAME ：重命名 DML （Data Manipulation Language）数据操纵语言:statements are used for managing data within schema objects，DML需要commit. SELECT ：查询记录 INSERT ：插入记录 UPDATE ：更新记录 DELETE ：删除记录 MERGE ：CALL ：调用 EXPLAIN PLAN：执行计划 LOCK TABLE ：锁表 DCL（Data Control Language）数据库控制语言:授权，角色控制等 *GRANT：授权 * REVOKE：取消授权 TCL（Transaction Control Language）事务控制语言 事务是一个不可分割的工作逻辑单元，可以使用事务来保证数据库的一致性和可恢复性，事务中的sql语句，==成功都成功，失败都失败。== 事务的ACID特性（4个英文首字母缩写）原子性一致性隔离性持久性 COMMIT命令用于提交并结束事务处理，对数据库执行永久性的事务更改SAVEPOINT保存点类似于标记，它将很长的事务处理划分为较小的部分。ROLLBACK命令用来撤销在当前事务中已完成的操作]]></content>
      <categories>
        <category>Oracle学习</category>
      </categories>
      <tags>
        <tag>Oracle学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络编程和线程]]></title>
    <url>%2F2019%2F07%2F20%2F4%2F</url>
    <content type="text"><![CDATA[[TOC] 网络编程网络协议TCP/IPUDP网络编程Socket/ServerSocketDatagramSocket 网络协议TCP协议是一个面向连接的、可靠的协议TCP(transmission control protocol)是专门设计用于在不可靠的因特网上提供可靠的、端到端的字节流通信的协议。它是一种面向连接的协议。TCP连接是字节流而非报文流。UDP协议是一个不可靠的、无连接协议UDP(user datagram protocol )UDP向应用程序提供了一种发送封装的原始IP数据报的方法、并且发送时无需建立连接。是一种不可靠的连接。 TCP编程TCP编程java.net.Socketjava.net.ServerSocket TCP编程的核心思路 开发服务器端ServerSocket ss = new ServerSocket(9000)ss.accept();开发客户端Socket s = new Socket(“150.236.56.101”, 9000) TCP编程 Server Client ServerSocket(port) Socket(server,port) ServerSocket.accept(); OutputStream Socket() InputStream OutputStream InputStream Socket.close() Socket.close() 总结服务器端：创建ServerSocket对象（并绑定端口）调用accept方法，等待来自客户端的连接调用getXXXStream方法，进行I/O关闭Socket客户端：创建Socket对象，并连接服务器调用getXXXStream方法，进行I/O关闭Socket UDP编程UDP协议简介UDP是一个无连接，不可靠的协议。即：数据的发送方只负责将数据发送出去，数据的接受方只负责接受数据。发送方和接收方不会相互确认数据的传输是否成功。 UDP编程12java.net.DatagramSocketjava.net. DatagramPacket UDP编程的核心思路12DatagramSocket socket = new DatagramSocket(9000) //接收端DatagramSocket socket = new DatagramSocket() //发送端 12345DatagramPacketDatagramPacket(byte[] buf, int off, int length)DatagramPacket(byte[] buf, int ,length, SoketAddress)getAddress()/getSockAddress()/getPort()/getLength()setAddress()/setSockAddress()/setPort()/setLength() 线程什么是线程在一个程序中同时运行的多个独立流程，每一个独立的流程就是一个线程线程并发多个线程并发执行主线程当JVM启动之后，加载类文件，发现main方法，那么就会为main方法创建一个线程，用于main方法执行，这个为main方法创建的线程称为主线程 Java中线程的使用在Java中创建线程的方法有两种 方法一继承java.lang.Thread类 方法二实现java.lang.Runnable接口 继承Thread类 自定义一个线程类继承自Thread 重写Thread的run方法 创建一个该类的对象 调用该类继承自Thread的start方法开启线程 Runnable接口开发线程 用户开发一个类实现Runnable接口 实现run() 运行线程 sleep方法void sleep(long time)方法用于使当前线程休眠指定的毫秒数 join方法 利用sleep方法对线程的控制是非常不精确的 join方法可以精确控制线程 join方法也会导致线程阻塞 特点：如果当前线程中调用了另外一个线程的 join方法，当前线程会立即阻塞，直到另外一个线程运行完成 线程同步产生数据不一致的原因多个线程并发访问了同一个对象，如果破坏了不可分割的操作，从而就会造成数据不一致被多线程并发访问时如果一个对象有可能出现数据不一致的问题,那么这个对象称为线程不安全的对象 如何解决多线程并发访问的问题123synchronized(object)&#123; 代码块 &#125;]]></content>
      <categories>
        <category>Java个人笔记</category>
      </categories>
      <tags>
        <tag>Java个人笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件和I/O流]]></title>
    <url>%2F2019%2F07%2F18%2F3%2F</url>
    <content type="text"><![CDATA[文件和I/O流大纲[TOC] 文件创建File对象File类的构造方法 由于File类的每一个对象都表示的是一个具体的目录或者文件，所以File类没有提供无参的构造方法，File类的所有构造方法都需要一个目录或者文件的路径作为参数 12345* File(String pathname)* File(String parent, String child)* File(File parent, String child) File类常用方法12345678910111213File类常用方法 boolean createNewFile()创建一个新文件 boolean mkdir() / mkdirs()创建新的目录 boolean delete() 删除文件或者目录 void deleteOnExit() 虚拟机退出时删除文件或者目录 boolean exists() 判断当前文件或者目录是否存在 boolean isFile() 判断File对象代表的是否是一个文件 boolean isDirectory() 判断File对象代表的是否是一个目录 String getPath() 返回当前File对象的字符串路径 String getName()返回当前File对象的文件名或者目录名 String getParent()返回当前File对象的父级目录 String getAbsolutePath()返回当前File对象的绝对路径 String[]list()返回当前File对象包含的子目录以及文件 HTML折叠语法12345&lt;details&gt; &lt;summary&gt;点击时的区域标题：点击查看详细内容&lt;/summary&gt; &lt;p&gt; - 测试 测试测试&lt;/p&gt; &lt;pre&gt;&lt;code&gt; title，value，callBack可以缺省 &lt;/code&gt; &lt;/pre&gt;&lt;/details&gt; 显示效果 点击时的区域标题：点击查看详细内容 - 测试 测试测试 title，value，callBack可以缺省 流==流在使用的时候一定要关闭，使用多种类型的流时，关闭最外层的流即可== 流的分类 按照流传输方向不同输入流（InputStream）输出流（OutputStream）按照处理数据类型的不同字节流字符流按照流的基本功能不同节点流过滤流 字节流字节流的概念传输的数据单位是字节，也意味着字节流能够处理任何一种文件字节流的组成字节输入流 InputStream（注意它是接口不能背实例化，使用时候一般结合FileInputStream实例化）字节输出流 OutputStream（注意它是接口不能背实例化使用时候一般结合FileOutputStream实例化） FileInputStream字节输入流类FileInputStream常用方法构造方法12FileInputStream (String filename)FileInputStream (File file) 常用方法1234close() int read()int read(byte[]b)int read(byte[] bs, int off, int len) FileOutputStream字节输出流类FileOutputStream常用方法常用构造方法1234FileOutputStream(String path)FileOutputStream(File file)FileOutputStream(String path, boolean append)FileOutputStream(File file, boolean append) 常用方法1234close()void write(int v)void write(byte[] bs)void write(byte[] bs, int off, int len) 字符流字符编码常见的 编码规范（字符集）ASCIIISO-8859-1GBKUTF-8乱码问题 FileReader123FileReader(String fileName)close()int read(char[] cbuf) FileWriter123FileWriter(String fileName)close()write(String value) InputStreamReader和OutputStreamWriter 特点：可以把一个字节流转换成一个字符流 在转换时可以执行编码方式 InputStreamReader123InputStreamReader(InputStream is)InputStreamReader(InputStream is ,String charSet)int read(char[] cbuf) OutputStreamWriter123OutputStreamWriter(OutputStream is) OutputStreamWriter(nOuputtStream is, String charSet)write(String value) 过滤流 Data Stream DataInputStream readXxx(); DataOutputStream writeXxx(); 过滤流的开发步骤 创建节点流 基于节点流创建过滤流 读/写数据 关闭外层流 创建节点流1FileOutputStream fout = new FileOutputStream("pi.data") 封装过滤流1DataOutputStream dout = new DataOutputStream(fout) 写数据1dout.writeDouble(3.14); 关闭外层流1dout.close() 1234567891011121314151617//创建节点流FileInputStream fin = new FileInputStream("pi.data");//封装过滤流DataInputStream din = new DataInputStream（fin);//读数据double pi = din.readDouble();//关闭外层流din.close();system.out.println(pi); BufferedOutputStream和基本字节输出流的区别：带了缓冲区，基本方法都一样 ObjectStream涉及概念：对象序列化（需要类实现Serializable接口,但并不需要实现具体方法） 操作对象的 123456ObjectStreamObjectInputStream ObjectOutputStreamObjectStream特点 writeObject() readObject() 12345678class Student implements Serializable&#123; String name; int age; public Student(Student name,int age)&#123; this.name = name; this.age = age; &#125;&#125; 123456Student stu1 = new Student("tom",18);Student stu2 = new Student("jerry",18);FileOutputStream oout = new ObjectOutputStream(fout);oout.writeObject(stu1);oout.writeObject(stu2);oout.close(); 1234567FileInputStream fin = new FileInputStream("stu.dat");ObjectInputStream oin = new ObjectInputStream(fin);Student s1 = (Student)oin.readObject();Studetn s2 = (Student)oin.readObject();oin.close();system.out.println(s1.name+""+s1.age);system.out.println(s2.name+""+s2.age); transient 关键字 序列化时注意事项不要使用追加的方式写对象如果一个对象的属性又是一个对象，则要求这个属性对象也实现了Serializable接口 ###]]></content>
      <categories>
        <category>Java个人笔记</category>
      </categories>
      <tags>
        <tag>Java个人笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-异常和集合]]></title>
    <url>%2F2019%2F07%2F17%2F2%2F</url>
    <content type="text"><![CDATA[7月13日异常和集合 异常 常见的几种异常类型 都继承自Exception，产生异常时，后面的语句不再执行（如果没有try，catch的话 ） try，catch，finally语句 在方法中的语句抛出异常throw new Exception（）； 方法抛出异常，在声明的后面加上 throws ** 可以多个catch，不过按顺序，第一个接受了就不会给第二个了 finnally无论如何都会执行，就算是catch里面有return也依然会执行 集合 要清楚各种集合之间的关系，collection是List和Set的父类，不过三者都是接口，均不能实例化，List的实现类有ArrayList（常用）和LinkedList两者区别不大，Set实现子类有HashSet（常用）和TreeSetMap接口及其实现类HashMap，Map不能包含重复的键 集合种的几种常用方法•Collaction接口的常用方法：size，isEmpty，contains，add，remove，iterator -list集合和set集合的区别，list集合可以加入重复的数据，set集合不可以，list集合是有顺序的，Hashset是无序的 ArrayList常用的方法：•get（index）返回指定位置的元素，特有•indexOf（object o）返回指定元素的所在位置•注意用remove方法的时候，删除一个后，后一个数移动到该位置上来 HashMap常用的方法：•put（key，valve）•get（key）返回指定键所对应的映射值•remove（key）如果存在一个键的映射关系那么移除•containKey（key）•containValve（valve）•set&lt; Entry&lt;key,value&gt;&gt;entrySet() 将Map变为Set，这样才能使用set的方法，从而使map和collection联系 遍历集合或者Map的方法•for（？：？）方法•Iterator-List和Set使用迭代器•Iterator i = list.Iterator();Map要想使用迭代器必须先转换成set（通过entrySet方法） -遍历的时候主要是用到两个方法•hasNext（）•next（）-注意set，list，map，Itterator后面都是跟着范型的 文件•java.io.File•– File用于表示硬盘中的一个文件或者文件夹•– File对象是java对象，包含文件的各种属性•– File对象可以代表还不存在的文件或文件夹•– File对象可以调用各种方法例如创建或删除•createNewFile和mkdir和mkdirs方法的区别•file.delete()可以删除文件和空文件夹，但是不能删除包含了一个有文件的文件夹]]></content>
      <categories>
        <category>Java个人笔记</category>
      </categories>
      <tags>
        <tag>Java个人笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客——MarkDown学习]]></title>
    <url>%2F2019%2F07%2F16%2F1%2F</url>
    <content type="text"><![CDATA[超链接 这里有四种方式 行内式行内式：[链接文字](http:www.hao123.com “链接属性”),（）里面写链接地址和链接属性，两者之间有一个空格，属性要加&quot; “下面做一个实验：链接文字，链接到百度好吧，应该是成功了，不过发现了一个问题，在引用里换行时候不需要输入两个空格 参考式分为两部分，先把链接文字写成来，给它做个标记，然后在下面在个标记赋值，也许你会问，这只是我的怀疑，我怀疑:代表赋值，语法大体如下：这是[百度] [1][1]: http:www.hao123.com “百度搜不到”参考式有一个优点就是在文章里有多个链接引用的时候，可以更好的对连接进行统一整理。 自动连接&lt;&gt;，代表自动链接，符号里面写网址，Markdown就会自动把它转换成链接，链接文字和链接地址一样，下面来实验一下自动链接百度http:www.hao123.com 锚点链接到文章内部的叫锚点，具体语法如下：语法和html一样。这里不写代码直接演示 锚点 跳转到锚点 列表无序列表使用 ，+，-表示无序列表 *发现了一个问题，在引用中你输入几个空格，它就显示几个空格,还不错**三个符号代表的无序列表显示是一样的，选择一种即可，我选择 *代码如下： - 无序列表项 一- 无序列表项二- 无序列表项三显示效果如下: 无序列表项 一 无序列表项 二 无序列表项 三 有序列表代码如下： 1. 有序列表 一2. 有序列表 二3. 有序列表 三显示效果： 有序列表项 一 有序列表项 二 有序列表项 三注意.后面有一个空格 包含段落的列表下面介绍包含段落列表：代码如下： 12345&gt; - 这是第一行&gt; 第一段&gt; 第二段&gt; - 这是第二行&gt; 显示效果如下： 这是第一行第一段第二段 这是第二行包含引用或者代码块的列表代码如下：* 阅读的方法： 打开书本打开电灯显示效果如下： 阅读的方法： 打开书本打开电灯 下面介绍包含代码块的：代码如下：* 包含代码快 &lt;代码写在这里&gt;显示效果如下: 包含代码块 12&gt; 大家好，我是列表下的代码块&gt; 让我看看这是哪一行？ 引用 首先这就是在一个引用里面写的代码如下：&gt; 这是一个引用显示效果如下： 这是一个引用当然由于本身已经在引用里面了所以这里发生了引用的多层嵌套，根据上面可以看出引用里面也可以使用其他语法，比如列表之类的 插入图像 插图像挺痛疼的，图床建立需要花钱，免费的又不稳定，只能在本地里面一张张的存图片了，哎代码:![图片描述]（图片地址 “图片Title”)显示效果：这里就不做演示了还有一种方法参考式和超链接的参考式一样 内容目录 在段落中写[]已显示全文内容的目录结构,里面是大写的toc代码:[TOC] 显示效果： [TOC]可以在任意的位置添加 注脚 注脚就是课本上对某些文字做注解的地方，一般课本的最后有做过注脚地方的解释。代码：这是一个注脚[^1][^1]：注脚是一种解释显示效果如下:这是一个注脚[^1][^1]: 注脚是一种解释脚注自动搬运到最后面，请到文章末尾查看，并且脚注后方的链接可以直接跳转到加注的地方 LaTeX公式 第一次见，初次见面，请多多关照🤭 $表示行内公式 $$表示整行公式 任务列表 代码:- [ ] 吃饭,代表没有选中的复选- [x] 吃饭,代表选中的复选显示效果如下: 吃饭,代表没有选中的复选 吃饭,代表选中的复选 表格 不管哪种方式,第一行为表头,第二行分隔表头和主体部分,第三行开始每一行为一个表格行 列和列之间使用管道符|隔开 第二行可以为不同的列指定对齐方式.默认为左对齐,在-右边加上:,该列就会右对齐代码如下:学号|姓名 -|-|-123|小明显示效果如下: 学号 姓名 123 小明 ## 代码 行内代码 多行代码 缩进式 子序列1 子子序列 下面推出上面又发现了多级列表的嵌套规则,根据*前面的制表符数匹配如何退出无序列表通过添加一个空白行 分割线代码:***显示效果如下:]]></content>
      <categories>
        <category>MarkDown学习笔记</category>
      </categories>
      <tags>
        <tag>MarkDown学习笔记</tag>
      </tags>
  </entry>
</search>
